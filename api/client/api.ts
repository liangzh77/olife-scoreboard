/* tslint:disable */
/* eslint-disable */
/**
 * Events Live Server API
 * Events Live Server API 文档
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AllControlsBriefEntity {
    'id': string;
    'name': string;
}
export interface AllControlsEntity {
    'id': string;
    'name': string;
    'terrainId': string;
}
export interface BatchCreateCompetitorFailedItem {
    'index': number;
    'reason': string;
}
export interface BatchCreateCompetitorPayload {
    'competitors': Array<CreateCompetitorPayload>;
}
export interface BatchCreateCompetitorResult {
    'success': Array<BatchCreateCompetitorSuccessItem>;
    'failed': Array<BatchCreateCompetitorFailedItem>;
}
export interface BatchCreateCompetitorSuccessItem {
    'index': number;
    'competitor': CompetitorEntity;
}
export interface BibEntity {
    'id': string;
    'eventId': string;
    'competitorId': string | null;
    'number': string;
}
export interface BindControlStationPayload {
    'stationId': string;
}
export interface ClassBriefEntity {
    'id': string;
    'name': string;
}
export interface ClassEntity {
    'id': string;
    'name': string;
    'type': string;
    'gender': string;
    'eventId': string;
    'ageMin': number | null;
    'ageMax': number | null;
}
export interface CompetitorBriefEntity {
    'id': string;
    'birthday': string;
    'country': string;
    'gender': string;
    'name': string;
}
export interface CompetitorBriefWithClassEntity {
    'id': string;
    'birthday': string;
    'country': string;
    'gender': string;
    'name': string;
    'class': Array<ClassBriefEntity>;
}
export interface CompetitorEntity {
    'id': string;
    'birthday': string;
    'country': string;
    'eventId': string;
    'gender': string;
    'name': string;
}
export interface CompetitorExtEntity {
    'id': string;
    'birthday': string;
    'country': string;
    'eventId': string;
    'gender': string;
    'name': string;
    'cardNbrs': Array<string>;
    'bibs': Array<string>;
    'courses': Array<CourseBriefEntity>;
    'regs': Array<RegistrationBriefEntity>;
    'team'?: TeamEntity;
}
export interface CompetitorLivePunchRecordEntity {
    'code': string;
    'valid': boolean;
    'time': number | null;
}
export interface CompetitorLiveResultEntity {
    'id': string;
    'competitor': CompetitorBriefEntity;
    'bibNumber': string;
    'startAt': string;
    'progress': number;
    'splitTimes': Array<CompetitorLivePunchRecordEntity>;
}
export interface CompetitorResultEntity {
    'id': string;
    'competitor': CompetitorBriefEntity;
    'bibNumber': string;
    'startAt': string | null;
    'finishAt': string | null;
    'status': string;
    'splitTimes': Array<ResultSplitTimeEntity>;
    'totalTime': number;
    'rank': number | null;
}
export interface CompetitorStatusEntity {
    'id': string;
    'competitor': CompetitorBriefEntity;
    'course': CourseBriefEntity | null;
    'status': string;
    'createdAt': string;
}
export interface ControlBindingEntity {
    'id': string;
    'allcontrolsId': string;
    'controlId': string;
    'stationId': string;
}
export interface ControlPointBriefEntity {
    'id': string;
    'code': string;
    'allControls': AllControlsBriefEntity;
}
export interface ControlPointEntity {
    'id': string;
    'allControlsId': string;
    'code': string;
    'coordinate'?: object;
    'symbol': string | null;
    'controlStations'?: Array<ControlStationEntity>;
}
export interface ControlStationEntity {
    'id': string;
    'controlCode': string;
    'deviceId': string;
    'status': string;
}
export interface CourseBriefEntity {
    'id': string;
    'name': string;
}
export interface CourseEntity {
    'id': string;
    'name': string;
    'stage': StageBriefEntity;
    'status': CourseEntityStatusEnum;
    'createdAt': string;
    'updatedAt': string;
    'class': ClassBriefEntity;
    'route': RouteBriefEntity;
    'courseRule': CourseRuleEntity;
    'startTime': string | null;
    /**
     * 比赛限时（分钟）
     */
    'timeLimit': number;
}

export const CourseEntityStatusEnum = {
    Stopped: 'stopped',
    Running: 'running'
} as const;

export type CourseEntityStatusEnum = typeof CourseEntityStatusEnum[keyof typeof CourseEntityStatusEnum];

export interface CourseInfoEntity {
    'id': string;
    'name': string;
    'class': ClassBriefEntity;
    'stage': StageBriefEntity;
    'event': EventBriefEntity;
    'controls': Array<string>;
}
export interface CourseResultEntity {
    'id': string;
    'course': CourseBriefEntity;
    'competitor': CompetitorBriefEntity;
    'startAt': string | null;
    'finishAt': string | null;
    'details': ResultDetailsEntity | null;
    'evaluated': boolean;
    'totalTime': number;
    'status': string;
    'rank': number | null;
    'remark': string | null;
    'createdAt': string;
    'updatedAt': string;
}
export interface CourseRuleEntity {
    'id': string;
    'eventId': string;
    'name': string;
    'courseType': CourseRuleEntityCourseTypeEnum;
    'finishTimeMode': CourseRuleEntityFinishTimeModeEnum;
    'indEvalRule': CourseRuleEntityIndEvalRuleEnum;
    'indRankingRule': CourseRuleEntityIndRankingRuleEnum;
    'startTimeMode': CourseRuleEntityStartTimeModeEnum;
    'teamEvalRuleAdmitTeamCount': CourseRuleEntityTeamEvalRuleAdmitTeamCountEnum;
    'teamEvalRuleValidResultMax': number;
    'teamEvalRuleValidResultMin': number;
    'teamRankingRule': CourseRuleEntityTeamRankingRuleEnum;
    'timeAccuracy': number;
}

export const CourseRuleEntityCourseTypeEnum = {
    TrailO: 'trail_o',
    ScoreO: 'score_o',
    RelayO: 'relay_o',
    ClassicArdf: 'classic_ardf',
    SprintArdf: 'sprint_ardf',
    FoxoringArdf: 'foxoring_ardf'
} as const;

export type CourseRuleEntityCourseTypeEnum = typeof CourseRuleEntityCourseTypeEnum[keyof typeof CourseRuleEntityCourseTypeEnum];
export const CourseRuleEntityFinishTimeModeEnum = {
    Chip: 'chip',
    Live: 'live',
    Station: 'station'
} as const;

export type CourseRuleEntityFinishTimeModeEnum = typeof CourseRuleEntityFinishTimeModeEnum[keyof typeof CourseRuleEntityFinishTimeModeEnum];
export const CourseRuleEntityIndEvalRuleEnum = {
    OrderedControls: 'ordered_controls',
    ScoreUnorderedControls: 'score_unordered_controls',
    ScoreMandatoryUnorderedControls: 'score_mandatory_unordered_controls',
    ScoreMandatoryOrderedControls: 'score_mandatory_ordered_controls',
    ScoreTimeWeighted: 'score_time_weighted',
    FoxoringArdf: 'foxoring_ardf'
} as const;

export type CourseRuleEntityIndEvalRuleEnum = typeof CourseRuleEntityIndEvalRuleEnum[keyof typeof CourseRuleEntityIndEvalRuleEnum];
export const CourseRuleEntityIndRankingRuleEnum = {
    ElapsedTime: 'elapsed_time',
    TotalScore: 'total_score',
    TotalScoreElapsedTime: 'total_score_elapsed_time'
} as const;

export type CourseRuleEntityIndRankingRuleEnum = typeof CourseRuleEntityIndRankingRuleEnum[keyof typeof CourseRuleEntityIndRankingRuleEnum];
export const CourseRuleEntityStartTimeModeEnum = {
    Grid: 'grid',
    MassStart: 'mass_start',
    Chip: 'chip',
    Live: 'live',
    Station: 'station'
} as const;

export type CourseRuleEntityStartTimeModeEnum = typeof CourseRuleEntityStartTimeModeEnum[keyof typeof CourseRuleEntityStartTimeModeEnum];
export const CourseRuleEntityTeamEvalRuleAdmitTeamCountEnum = {
    ValidResultsMin: 'valid_results_min',
    ValidResultsMax: 'valid_results_max',
    AdmitTeamCount: 'admit_team_count'
} as const;

export type CourseRuleEntityTeamEvalRuleAdmitTeamCountEnum = typeof CourseRuleEntityTeamEvalRuleAdmitTeamCountEnum[keyof typeof CourseRuleEntityTeamEvalRuleAdmitTeamCountEnum];
export const CourseRuleEntityTeamRankingRuleEnum = {
    ElapsedTime: 'elapsed_time',
    TotalScore: 'total_score',
    TotalScoreElapsedTime: 'total_score_elapsed_time'
} as const;

export type CourseRuleEntityTeamRankingRuleEnum = typeof CourseRuleEntityTeamRankingRuleEnum[keyof typeof CourseRuleEntityTeamRankingRuleEnum];

export interface CourseTrackingBoardEntity {
    'courseInfo': CourseInfoEntity;
    'results': Array<CompetitorResultEntity>;
    'liveResults': Array<CompetitorLiveResultEntity>;
}
export interface CreateAllControlsPayload {
    'name': string;
    'terrainId': string;
}
export interface CreateBibPayload {
    'eventId': string;
    'competitorId'?: string | null;
    'number': string;
}
export interface CreateClassPayload {
    'name': string;
    'type': string;
    'gender': string;
    'eventId': string;
    'ageMin'?: number | null;
    'ageMax'?: number | null;
}
export interface CreateCompetitorPayload {
    'name': string;
    'birthday': string;
    'country': string;
    'eventId': string;
    'gender': string;
    'teamId'?: string | null;
}
export interface CreateControlPointPayload {
    'allControlsId': string;
    'code': string;
    'coordinate'?: object;
    'symbol'?: string | null;
}
export interface CreateControlStationPayload {
    'deviceId': string;
    'controlCode': string;
}
export interface CreateCoursePayload {
    'name': string;
    'classId': string;
    'routeId': string;
    'courseRuleId': string;
    'stageId': string;
    'startTime'?: string;
    /**
     * 比赛限时（分钟）
     */
    'timeLimit': number;
}
export interface CreateCourseRulePayload {
    'name': string;
    'eventId': string;
    'courseType': CreateCourseRulePayloadCourseTypeEnum;
    'finishTimeMode': CreateCourseRulePayloadFinishTimeModeEnum;
    'indEvalRule': CreateCourseRulePayloadIndEvalRuleEnum;
    'indRankingRule': CreateCourseRulePayloadIndRankingRuleEnum;
    'startTimeMode': CreateCourseRulePayloadStartTimeModeEnum;
    'teamRankingRule': CreateCourseRulePayloadTeamRankingRuleEnum;
    'timeAccuracy': number;
    /**
     * 允许计入团队成绩的队伍数量
     */
    'teamEvalRuleAdmitTeamCount': number;
    /**
     * 团队成绩中可计入的有效个人成绩人数上限
     */
    'teamEvalRuleValidResultMax': number;
    /**
     * 团队成绩中可计入的有效个人成绩人数下限
     */
    'teamEvalRuleValidResultMin': number;
}

export const CreateCourseRulePayloadCourseTypeEnum = {
    TrailO: 'trail_o',
    ScoreO: 'score_o',
    RelayO: 'relay_o',
    ClassicArdf: 'classic_ardf',
    SprintArdf: 'sprint_ardf',
    FoxoringArdf: 'foxoring_ardf'
} as const;

export type CreateCourseRulePayloadCourseTypeEnum = typeof CreateCourseRulePayloadCourseTypeEnum[keyof typeof CreateCourseRulePayloadCourseTypeEnum];
export const CreateCourseRulePayloadFinishTimeModeEnum = {
    Chip: 'chip',
    Live: 'live',
    Station: 'station'
} as const;

export type CreateCourseRulePayloadFinishTimeModeEnum = typeof CreateCourseRulePayloadFinishTimeModeEnum[keyof typeof CreateCourseRulePayloadFinishTimeModeEnum];
export const CreateCourseRulePayloadIndEvalRuleEnum = {
    OrderedControls: 'ordered_controls',
    ScoreUnorderedControls: 'score_unordered_controls',
    ScoreMandatoryUnorderedControls: 'score_mandatory_unordered_controls',
    ScoreMandatoryOrderedControls: 'score_mandatory_ordered_controls',
    ScoreTimeWeighted: 'score_time_weighted',
    FoxoringArdf: 'foxoring_ardf'
} as const;

export type CreateCourseRulePayloadIndEvalRuleEnum = typeof CreateCourseRulePayloadIndEvalRuleEnum[keyof typeof CreateCourseRulePayloadIndEvalRuleEnum];
export const CreateCourseRulePayloadIndRankingRuleEnum = {
    ElapsedTime: 'elapsed_time',
    TotalScore: 'total_score',
    TotalScoreElapsedTime: 'total_score_elapsed_time'
} as const;

export type CreateCourseRulePayloadIndRankingRuleEnum = typeof CreateCourseRulePayloadIndRankingRuleEnum[keyof typeof CreateCourseRulePayloadIndRankingRuleEnum];
export const CreateCourseRulePayloadStartTimeModeEnum = {
    Grid: 'grid',
    MassStart: 'mass_start',
    Chip: 'chip',
    Live: 'live',
    Station: 'station'
} as const;

export type CreateCourseRulePayloadStartTimeModeEnum = typeof CreateCourseRulePayloadStartTimeModeEnum[keyof typeof CreateCourseRulePayloadStartTimeModeEnum];
export const CreateCourseRulePayloadTeamRankingRuleEnum = {
    ElapsedTime: 'elapsed_time',
    TotalScore: 'total_score',
    TotalScoreElapsedTime: 'total_score_elapsed_time'
} as const;

export type CreateCourseRulePayloadTeamRankingRuleEnum = typeof CreateCourseRulePayloadTeamRankingRuleEnum[keyof typeof CreateCourseRulePayloadTeamRankingRuleEnum];

export interface CreateEventPayload {
    'name': string;
    'description'?: string | null;
    'startAt': string;
    'endAt': string;
}
export interface CreateFingerCardPayload {
    'cardNbr': string;
    'competitorId'?: string | null;
    'eventId': string;
}
export interface CreatePunchRecordPayload {
    'eventId': string;
    'model': string;
    'cardNbr': string;
    'startTime': string;
    'finishTime': string;
    'punchs': Array<PunchDto>;
    'hash': string;
    'rawdata': string;
}
export interface CreateRegistrationPayload {
    'classId': string;
    'competitorId': string;
    'eventId': string;
}
export interface CreateRoutePayload {
    'name': string;
    'terrainId': string;
    'allcontrolsId': string;
    'distance': number;
    'climb': number;
}
export interface CreateStagePayload {
    'name': string;
    'description'?: string | null;
    'startAt': string;
    'endAt': string;
    'eventId': string;
    'index': number;
}
export interface CreateTeamPayload {
    'name': string;
    'unitId': string;
    'eventId': string;
}
export interface CreateTeamResultGroupItemPayload {
    'courseId': string;
}
export interface CreateTeamResultGroupPayload {
    'name': string;
    'stageId': string;
}
export interface CreateTerrainPayload {
    'name': string;
    'eventId': string;
}
export interface CreateUnitPayload {
    'name': string;
    'eventId': string;
    'country'?: string | null;
}
export interface DeleteRouteControlPointsPayload {
    'routeControlIds': Array<string>;
}
export interface EvaluateResultsDto {
    'courseId': string;
    /**
     * 评估方式: all(全部), new(仅新成绩)
     */
    'method': EvaluateResultsDtoMethodEnum;
}

export const EvaluateResultsDtoMethodEnum = {
    All: 'all',
    New: 'new'
} as const;

export type EvaluateResultsDtoMethodEnum = typeof EvaluateResultsDtoMethodEnum[keyof typeof EvaluateResultsDtoMethodEnum];

export interface EventBriefEntity {
    'id': string;
    'name': string;
}
export interface EventEntity {
    'id': string;
    'name': string;
    'description': string | null;
    'startAt': string;
    'endAt': string;
    'status': string;
    'createdAt': string;
    'updatedAt': string;
}
export interface FingerCardEntity {
    'cardNbr': string;
    'competitorId': string | null;
    'eventId': string;
}
export interface InsertRouteControlPointsPayload {
    'action': string;
    'targetRouteControlId'?: string;
    'controlIds': Array<string>;
}
export interface LoginDto {
    'email': string;
    'password': string;
}
export interface MoveRouteControlPointPayload {
    'routeControlId': string;
    'targetRouteControlId'?: string | null;
}
export interface ObjectEntity {
    'id': string;
}
export interface Pagination {
    'total': number;
    'current': number | null;
    'pageSize': number | null;
}
export interface ProfileEntity {
    'id': string;
    'email': string | null;
    'phone': string | null;
    'username': string | null;
    'fullname': string | null;
    'avatarUrl': string | null;
    'roles': Array<string>;
    'updatedAt': string;
}
export interface PunchDto {
    'code': string;
    'time': string;
}
export interface PunchRecordEntity {
    'id': string;
    'competitor': CompetitorBriefEntity;
    'control': ControlPointBriefEntity;
    'course': CourseBriefEntity;
    'deviceId': string | null;
    'code': string;
    'punchAt': string;
    'uploadAt': string;
    'rawdata': { [key: string]: any; } | null;
    'cardNbr': string;
    'createdAt': string;
    'batch': string | null;
    'source': PunchRecordEntitySourceEnum;
}

export const PunchRecordEntitySourceEnum = {
    CloudReader: 'cloud_reader',
    FingerCard: 'finger_card',
    Station: 'station'
} as const;

export type PunchRecordEntitySourceEnum = typeof PunchRecordEntitySourceEnum[keyof typeof PunchRecordEntitySourceEnum];

export interface RegisterPayload {
    'email': string;
    'password': string;
    'username'?: string;
    'fullname'?: string;
    'avatarUrl'?: string;
}
export interface RegistrationBriefEntity {
    'id': string;
    'class': ClassBriefEntity;
}
export interface RegistrationEntity {
    'id': string;
    'class': ClassBriefEntity;
    'competitor': CompetitorBriefEntity;
    'eventId': string;
    'createdAt': string;
    'updatedAt': string;
    'regAt': string;
}
export interface RestDataResponseOfAllControlsEntity {
    'code': number;
    'msg': string;
    'data': AllControlsEntity;
}
export interface RestDataResponseOfAllControlsEntityArray {
    'code': number;
    'msg': string;
    'data': Array<AllControlsEntity>;
}
export interface RestDataResponseOfBatchCreateCompetitorResult {
    'code': number;
    'msg': string;
    'data': BatchCreateCompetitorResult;
}
export interface RestDataResponseOfBibEntity {
    'code': number;
    'msg': string;
    'data': BibEntity;
}
export interface RestDataResponseOfBibEntityArray {
    'code': number;
    'msg': string;
    'data': Array<BibEntity>;
    'pagination': Pagination;
}
export interface RestDataResponseOfBibEntityArray1 {
    'code': number;
    'msg': string;
    'data': Array<BibEntity>;
}
export interface RestDataResponseOfClassEntity {
    'code': number;
    'msg': string;
    'data': ClassEntity;
}
export interface RestDataResponseOfClassEntityArray {
    'code': number;
    'msg': string;
    'data': Array<ClassEntity>;
}
export interface RestDataResponseOfCompetitorBriefWithClassEntity {
    'code': number;
    'msg': string;
    'data': CompetitorBriefWithClassEntity;
}
export interface RestDataResponseOfCompetitorBriefWithClassEntityArray {
    'code': number;
    'msg': string;
    'data': Array<CompetitorBriefWithClassEntity>;
}
export interface RestDataResponseOfCompetitorEntity {
    'code': number;
    'msg': string;
    'data': CompetitorEntity;
}
export interface RestDataResponseOfCompetitorExtEntity {
    'code': number;
    'msg': string;
    'data': CompetitorExtEntity;
}
export interface RestDataResponseOfCompetitorExtEntityArray {
    'code': number;
    'msg': string;
    'data': Array<CompetitorExtEntity>;
    'pagination': Pagination;
}
export interface RestDataResponseOfCompetitorStatusEntityArray {
    'code': number;
    'msg': string;
    'data': Array<CompetitorStatusEntity>;
    'pagination': Pagination;
}
export interface RestDataResponseOfControlBindingEntity {
    'code': number;
    'msg': string;
    'data': ControlBindingEntity;
}
export interface RestDataResponseOfControlPointEntity {
    'code': number;
    'msg': string;
    'data': ControlPointEntity;
}
export interface RestDataResponseOfControlPointEntityArray {
    'code': number;
    'msg': string;
    'data': Array<ControlPointEntity>;
}
export interface RestDataResponseOfControlStationEntity {
    'code': number;
    'msg': string;
    'data': ControlStationEntity;
}
export interface RestDataResponseOfControlStationEntityArray {
    'code': number;
    'msg': string;
    'data': Array<ControlStationEntity>;
}
export interface RestDataResponseOfCourseEntity {
    'code': number;
    'msg': string;
    'data': CourseEntity;
}
export interface RestDataResponseOfCourseEntityArray {
    'code': number;
    'msg': string;
    'data': Array<CourseEntity>;
}
export interface RestDataResponseOfCourseResultEntityArray {
    'code': number;
    'msg': string;
    'data': Array<CourseResultEntity>;
    'pagination': Pagination;
}
export interface RestDataResponseOfCourseRuleEntity {
    'code': number;
    'msg': string;
    'data': CourseRuleEntity;
}
export interface RestDataResponseOfCourseRuleEntityArray {
    'code': number;
    'msg': string;
    'data': Array<CourseRuleEntity>;
}
export interface RestDataResponseOfCourseTrackingBoardEntity {
    'code': number;
    'msg': string;
    'data': CourseTrackingBoardEntity;
}
export interface RestDataResponseOfEventEntity {
    'code': number;
    'msg': string;
    'data': EventEntity;
}
export interface RestDataResponseOfEventEntityArray {
    'code': number;
    'msg': string;
    'data': Array<EventEntity>;
}
export interface RestDataResponseOfFingerCardEntity {
    'code': number;
    'msg': string;
    'data': FingerCardEntity;
}
export interface RestDataResponseOfFingerCardEntityArray {
    'code': number;
    'msg': string;
    'data': Array<FingerCardEntity>;
}
export interface RestDataResponseOfObjectEntityArray {
    'code': number;
    'msg': string;
    'data': Array<ObjectEntity>;
}
export interface RestDataResponseOfProfileEntity {
    'code': number;
    'msg': string;
    'data': ProfileEntity;
}
export interface RestDataResponseOfPunchRecordEntityArray {
    'code': number;
    'msg': string;
    'data': Array<PunchRecordEntity>;
    'pagination': Pagination;
}
export interface RestDataResponseOfRegisterPayload {
    'code': number;
    'msg': string;
    'data': RegisterPayload;
}
export interface RestDataResponseOfRegistrationEntity {
    'code': number;
    'msg': string;
    'data': RegistrationEntity;
}
export interface RestDataResponseOfRegistrationEntityArray {
    'code': number;
    'msg': string;
    'data': Array<RegistrationEntity>;
}
export interface RestDataResponseOfRouteControlPointEntityArray {
    'code': number;
    'msg': string;
    'data': Array<RouteControlPointEntity>;
}
export interface RestDataResponseOfRouteEntity {
    'code': number;
    'msg': string;
    'data': RouteEntity;
}
export interface RestDataResponseOfRouteEntityArray {
    'code': number;
    'msg': string;
    'data': Array<RouteEntity>;
}
export interface RestDataResponseOfStageEntity {
    'code': number;
    'msg': string;
    'data': StageEntity;
}
export interface RestDataResponseOfStageEntityArray {
    'code': number;
    'msg': string;
    'data': Array<StageEntity>;
}
export interface RestDataResponseOfTeamEntity {
    'code': number;
    'msg': string;
    'data': TeamEntity;
}
export interface RestDataResponseOfTeamEntityArray {
    'code': number;
    'msg': string;
    'data': Array<TeamEntity>;
}
export interface RestDataResponseOfTeamEntityArray1 {
    'code': number;
    'msg': string;
    'data': Array<TeamEntity>;
    'pagination': Pagination;
}
export interface RestDataResponseOfTeamResultGroupEntity {
    'code': number;
    'msg': string;
    'data': TeamResultGroupEntity;
}
export interface RestDataResponseOfTeamResultGroupEntityArray {
    'code': number;
    'msg': string;
    'data': Array<TeamResultGroupEntity>;
}
export interface RestDataResponseOfTeamResultGroupItemEntity {
    'code': number;
    'msg': string;
    'data': TeamResultGroupItemEntity;
}
export interface RestDataResponseOfTerrainEntity {
    'code': number;
    'msg': string;
    'data': TerrainEntity;
}
export interface RestDataResponseOfTerrainEntityArray {
    'code': number;
    'msg': string;
    'data': Array<TerrainEntity>;
}
export interface RestDataResponseOfTrackBoardEventEntityArray {
    'code': number;
    'msg': string;
    'data': Array<TrackBoardEventEntity>;
}
export interface RestDataResponseOfUnitEntity {
    'code': number;
    'msg': string;
    'data': UnitEntity;
}
export interface RestDataResponseOfUnitEntityArray {
    'code': number;
    'msg': string;
    'data': Array<UnitEntity>;
    'pagination': Pagination;
}
export interface RestDataResponseOfUserEntity {
    'code': number;
    'msg': string;
    'data': UserEntity;
}
export interface RestResponse {
    'code': number;
    'msg': string;
}
export interface ResultDetailSplitTimeEntity {
    'code': string;
    'valid': boolean;
    'punchAt': string | null;
}
export interface ResultDetailsEntity {
    'splitTimes': Array<ResultDetailSplitTimeEntity>;
}
export interface ResultSplitTimeEntity {
    'code': string;
    'valid': boolean;
    'time': number;
}
export interface RouteBriefEntity {
    'id': string;
    'name': string;
}
export interface RouteControlPointEntity {
    'id': string;
    'controlId': string;
    'routeId': string;
    'index': number;
    'control': ControlPointEntity | null;
}
export interface RouteEntity {
    'id': string;
    'name': string;
    'terrainId': string;
    'allcontrolsId': string;
    'distance': number;
    'climb': number;
}
export interface StageBriefEntity {
    'id': string;
    'name': string;
}
export interface StageEntity {
    'id': string;
    'name': string;
    'description': string | null;
    'startAt': string;
    'endAt': string;
    'status': string;
    'eventId': string;
    'index': number;
    'createdAt': string;
    'updatedAt': string;
}
export interface TeamEntity {
    'id': string;
    'name': string;
    'unit': UnitEntity;
}
export interface TeamResultGroupEntity {
    'id': string;
    'name': string;
    'stageId': string;
    'items': Array<TeamResultGroupItemEntity>;
}
export interface TeamResultGroupItemEntity {
    'id': string;
    'courseId': string;
    'trgId': string;
}
export interface TerrainEntity {
    'id': string;
    'name': string;
    'eventId': string;
}
export interface TrackBoardCourseEntity {
    'id': string;
    'name': string;
    'status': TrackBoardCourseEntityStatusEnum;
    'class': ClassBriefEntity;
}

export const TrackBoardCourseEntityStatusEnum = {
    Stopped: 'stopped',
    Running: 'running'
} as const;

export type TrackBoardCourseEntityStatusEnum = typeof TrackBoardCourseEntityStatusEnum[keyof typeof TrackBoardCourseEntityStatusEnum];

export interface TrackBoardEventEntity {
    'id': string;
    'name': string;
    'description': string | null;
    'startAt': string;
    'endAt': string;
    'status': string;
    'stages': Array<TrackBoardStageEntity>;
}
export interface TrackBoardStageEntity {
    'id': string;
    'name': string;
    'description': string | null;
    'startAt': string;
    'endAt': string;
    'status': string;
    'courses': Array<TrackBoardCourseEntity>;
}
export interface UnbindControlStationPayload {
    'stationId': string;
}
export interface UnitEntity {
    'id': string;
    'name': string;
    'country': string | null;
    'eventId': string;
}
export interface UpdateAllControlsPayload {
    'name'?: string;
}
export interface UpdateBibPayload {
    'competitorId'?: string | null;
    'number'?: string;
    'eventId': string;
}
export interface UpdateClassPayload {
    'name'?: string;
    'type'?: string;
    'gender'?: string;
    'ageMin'?: number | null;
    'ageMax'?: number | null;
}
export interface UpdateCompetitorPayload {
    'name'?: string;
    'birthday'?: string;
    'country'?: string;
    'gender'?: string;
    'teamId'?: string | null;
}
export interface UpdateControlPointPayload {
    'code'?: string;
    'coordinate'?: object;
    'symbol'?: string | null;
}
export interface UpdateControlStationPayload {
    'deviceId'?: string;
    'controlCode'?: string;
    'status'?: string;
}
export interface UpdateCoursePayload {
    'name'?: string;
    'classId'?: string;
    'routeId'?: string;
    'courseRuleId'?: string;
    'stageId'?: string;
    'status'?: UpdateCoursePayloadStatusEnum;
    'startTime'?: string;
    /**
     * 比赛限时（分钟）
     */
    'timeLimit'?: number;
}

export const UpdateCoursePayloadStatusEnum = {
    Stopped: 'stopped',
    Running: 'running'
} as const;

export type UpdateCoursePayloadStatusEnum = typeof UpdateCoursePayloadStatusEnum[keyof typeof UpdateCoursePayloadStatusEnum];

export interface UpdateCourseRulePayload {
    'name'?: string;
    'courseType'?: UpdateCourseRulePayloadCourseTypeEnum;
    'finishTimeMode'?: UpdateCourseRulePayloadFinishTimeModeEnum;
    'indEvalRule'?: UpdateCourseRulePayloadIndEvalRuleEnum;
    'indRankingRule'?: UpdateCourseRulePayloadIndRankingRuleEnum;
    'startTimeMode'?: UpdateCourseRulePayloadStartTimeModeEnum;
    'teamRankingRule'?: UpdateCourseRulePayloadTeamRankingRuleEnum;
    'timeAccuracy'?: number;
    /**
     * 允许计入团队成绩的队伍数量
     */
    'teamEvalRuleAdmitTeamCount'?: number;
    /**
     * 团队成绩中可计入的有效个人成绩人数上限
     */
    'teamEvalRuleValidResultMax'?: number;
    /**
     * 团队成绩中可计入的有效个人成绩人数下限
     */
    'teamEvalRuleValidResultMin'?: number;
}

export const UpdateCourseRulePayloadCourseTypeEnum = {
    TrailO: 'trail_o',
    ScoreO: 'score_o',
    RelayO: 'relay_o',
    ClassicArdf: 'classic_ardf',
    SprintArdf: 'sprint_ardf',
    FoxoringArdf: 'foxoring_ardf'
} as const;

export type UpdateCourseRulePayloadCourseTypeEnum = typeof UpdateCourseRulePayloadCourseTypeEnum[keyof typeof UpdateCourseRulePayloadCourseTypeEnum];
export const UpdateCourseRulePayloadFinishTimeModeEnum = {
    Chip: 'chip',
    Live: 'live',
    Station: 'station'
} as const;

export type UpdateCourseRulePayloadFinishTimeModeEnum = typeof UpdateCourseRulePayloadFinishTimeModeEnum[keyof typeof UpdateCourseRulePayloadFinishTimeModeEnum];
export const UpdateCourseRulePayloadIndEvalRuleEnum = {
    OrderedControls: 'ordered_controls',
    ScoreUnorderedControls: 'score_unordered_controls',
    ScoreMandatoryUnorderedControls: 'score_mandatory_unordered_controls',
    ScoreMandatoryOrderedControls: 'score_mandatory_ordered_controls',
    ScoreTimeWeighted: 'score_time_weighted',
    FoxoringArdf: 'foxoring_ardf'
} as const;

export type UpdateCourseRulePayloadIndEvalRuleEnum = typeof UpdateCourseRulePayloadIndEvalRuleEnum[keyof typeof UpdateCourseRulePayloadIndEvalRuleEnum];
export const UpdateCourseRulePayloadIndRankingRuleEnum = {
    ElapsedTime: 'elapsed_time',
    TotalScore: 'total_score',
    TotalScoreElapsedTime: 'total_score_elapsed_time'
} as const;

export type UpdateCourseRulePayloadIndRankingRuleEnum = typeof UpdateCourseRulePayloadIndRankingRuleEnum[keyof typeof UpdateCourseRulePayloadIndRankingRuleEnum];
export const UpdateCourseRulePayloadStartTimeModeEnum = {
    Grid: 'grid',
    MassStart: 'mass_start',
    Chip: 'chip',
    Live: 'live',
    Station: 'station'
} as const;

export type UpdateCourseRulePayloadStartTimeModeEnum = typeof UpdateCourseRulePayloadStartTimeModeEnum[keyof typeof UpdateCourseRulePayloadStartTimeModeEnum];
export const UpdateCourseRulePayloadTeamRankingRuleEnum = {
    ElapsedTime: 'elapsed_time',
    TotalScore: 'total_score',
    TotalScoreElapsedTime: 'total_score_elapsed_time'
} as const;

export type UpdateCourseRulePayloadTeamRankingRuleEnum = typeof UpdateCourseRulePayloadTeamRankingRuleEnum[keyof typeof UpdateCourseRulePayloadTeamRankingRuleEnum];

export interface UpdateEventPayload {
    'name'?: string;
    'description'?: string | null;
    'startAt'?: string;
    'endAt'?: string;
    'status'?: string;
}
export interface UpdateFingerCardPayload {
    'cardNbr'?: string;
    'competitorId'?: string | null;
    'eventId': string;
}
export interface UpdateRegistrationPayload {
    'classId'?: string;
}
export interface UpdateRoutePayload {
    'name'?: string;
    'distance'?: number;
    'climb'?: number;
}
export interface UpdateStagePayload {
    'name'?: string;
    'description'?: string | null;
    'startAt'?: string;
    'endAt'?: string;
    'status'?: string;
    'index'?: number;
}
export interface UpdateTeamPayload {
    'name'?: string;
    'unitId'?: string;
}
export interface UpdateTeamResultGroupPayload {
    'name'?: string;
}
export interface UpdateTerrainPayload {
    'name'?: string;
}
export interface UpdateUnitPayload {
    'name'?: string;
    'country'?: string | null;
}
export interface UserEntity {
    'id': string;
    'email': string;
    'phone': string;
    'name': string;
    'roles': Array<string>;
}

/**
 * AllControlsApi - axios parameter creator
 */
export const AllControlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createAllControls
         * @param {CreateAllControlsPayload} createAllControlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllControls: async (createAllControlsPayload: CreateAllControlsPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAllControlsPayload' is not null or undefined
            assertParamExists('createAllControls', 'createAllControlsPayload', createAllControlsPayload)
            const localVarPath = `/allcontrols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAllControlsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteAllControls
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllControls: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAllControls', 'id', id)
            const localVarPath = `/allcontrols/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllControlsByControlId
         * @param {string} controlId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlsByControlId: async (controlId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'controlId' is not null or undefined
            assertParamExists('getAllControlsByControlId', 'controlId', controlId)
            const localVarPath = `/allcontrols/controlpoint/{controlId}`
                .replace(`{${"controlId"}}`, encodeURIComponent(String(controlId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllControlsById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlsById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllControlsById', 'id', id)
            const localVarPath = `/allcontrols/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllControlsByTerrainId
         * @param {string} terrain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlsByTerrainId: async (terrain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terrain' is not null or undefined
            assertParamExists('getAllControlsByTerrainId', 'terrain', terrain)
            const localVarPath = `/allcontrols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (terrain !== undefined) {
                localVarQueryParameter['terrain'] = terrain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAvailableStations
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStations: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAvailableStations', 'id', id)
            const localVarPath = `/allcontrols/{id}/stations/available`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getControlPointsByAllControlsId
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlPointsByAllControlsId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getControlPointsByAllControlsId', 'id', id)
            const localVarPath = `/allcontrols/{id}/controlpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateAllControls
         * @param {string} id 
         * @param {UpdateAllControlsPayload} updateAllControlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAllControls: async (id: string, updateAllControlsPayload: UpdateAllControlsPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAllControls', 'id', id)
            // verify required parameter 'updateAllControlsPayload' is not null or undefined
            assertParamExists('updateAllControls', 'updateAllControlsPayload', updateAllControlsPayload)
            const localVarPath = `/allcontrols/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAllControlsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllControlsApi - functional programming interface
 */
export const AllControlsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllControlsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createAllControls
         * @param {CreateAllControlsPayload} createAllControlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAllControls(createAllControlsPayload: CreateAllControlsPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfAllControlsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAllControls(createAllControlsPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.createAllControls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteAllControls
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllControls(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllControls(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.deleteAllControls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getAllControlsByControlId
         * @param {string} controlId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllControlsByControlId(controlId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfAllControlsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllControlsByControlId(controlId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.getAllControlsByControlId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getAllControlsById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllControlsById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfAllControlsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllControlsById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.getAllControlsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getAllControlsByTerrainId
         * @param {string} terrain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllControlsByTerrainId(terrain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfAllControlsEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllControlsByTerrainId(terrain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.getAllControlsByTerrainId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getAvailableStations
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableStations(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlStationEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableStations(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.getAvailableStations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getControlPointsByAllControlsId
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlPointsByAllControlsId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlPointEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlPointsByAllControlsId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.getControlPointsByAllControlsId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateAllControls
         * @param {string} id 
         * @param {UpdateAllControlsPayload} updateAllControlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAllControls(id: string, updateAllControlsPayload: UpdateAllControlsPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfAllControlsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAllControls(id, updateAllControlsPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllControlsApi.updateAllControls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllControlsApi - factory interface
 */
export const AllControlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllControlsApiFp(configuration)
    return {
        /**
         * 
         * @summary createAllControls
         * @param {CreateAllControlsPayload} createAllControlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllControls(createAllControlsPayload: CreateAllControlsPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfAllControlsEntity> {
            return localVarFp.createAllControls(createAllControlsPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteAllControls
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllControls(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteAllControls(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllControlsByControlId
         * @param {string} controlId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlsByControlId(controlId: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfAllControlsEntity> {
            return localVarFp.getAllControlsByControlId(controlId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllControlsById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlsById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfAllControlsEntity> {
            return localVarFp.getAllControlsById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllControlsByTerrainId
         * @param {string} terrain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlsByTerrainId(terrain: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfAllControlsEntityArray> {
            return localVarFp.getAllControlsByTerrainId(terrain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAvailableStations
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableStations(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlStationEntityArray> {
            return localVarFp.getAvailableStations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getControlPointsByAllControlsId
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlPointsByAllControlsId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlPointEntityArray> {
            return localVarFp.getControlPointsByAllControlsId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateAllControls
         * @param {string} id 
         * @param {UpdateAllControlsPayload} updateAllControlsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAllControls(id: string, updateAllControlsPayload: UpdateAllControlsPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfAllControlsEntity> {
            return localVarFp.updateAllControls(id, updateAllControlsPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllControlsApi - object-oriented interface
 */
export class AllControlsApi extends BaseAPI {
    /**
     * 
     * @summary createAllControls
     * @param {CreateAllControlsPayload} createAllControlsPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAllControls(createAllControlsPayload: CreateAllControlsPayload, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).createAllControls(createAllControlsPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteAllControls
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAllControls(id: string, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).deleteAllControls(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllControlsByControlId
     * @param {string} controlId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllControlsByControlId(controlId: string, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).getAllControlsByControlId(controlId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllControlsById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllControlsById(id: string, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).getAllControlsById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllControlsByTerrainId
     * @param {string} terrain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllControlsByTerrainId(terrain: string, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).getAllControlsByTerrainId(terrain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAvailableStations
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAvailableStations(id: string, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).getAvailableStations(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getControlPointsByAllControlsId
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getControlPointsByAllControlsId(id: string, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).getControlPointsByAllControlsId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateAllControls
     * @param {string} id 
     * @param {UpdateAllControlsPayload} updateAllControlsPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAllControls(id: string, updateAllControlsPayload: UpdateAllControlsPayload, options?: RawAxiosRequestConfig) {
        return AllControlsApiFp(this.configuration).updateAllControls(id, updateAllControlsPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('login', 'loginDto', loginDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary register
         * @param {RegisterPayload} registerPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerPayload: RegisterPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerPayload' is not null or undefined
            assertParamExists('register', 'registerPayload', registerPayload)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfProfileEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfUserEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary register
         * @param {RegisterPayload} registerPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerPayload: RegisterPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRegisterPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary getProfile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfProfileEntity> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary login
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginDto: LoginDto, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfUserEntity> {
            return localVarFp.login(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary register
         * @param {RegisterPayload} registerPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerPayload: RegisterPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRegisterPayload> {
            return localVarFp.register(registerPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary getProfile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProfile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary login
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary register
     * @param {RegisterPayload} registerPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(registerPayload: RegisterPayload, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BibApi - axios parameter creator
 */
export const BibApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createBib
         * @param {CreateBibPayload} createBibPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBib: async (createBibPayload: CreateBibPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBibPayload' is not null or undefined
            assertParamExists('createBib', 'createBibPayload', createBibPayload)
            const localVarPath = `/bib`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBibPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteBib
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBib: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBib', 'id', id)
            const localVarPath = `/bib/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAvailableBibs
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBibs: async (event: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getAvailableBibs', 'event', event)
            const localVarPath = `/bib/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBibById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBibById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBibById', 'id', id)
            const localVarPath = `/bib/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBibs
         * @param {string} [event] 
         * @param {string} [competitor] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBibs: async (event?: string, competitor?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bib`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (competitor !== undefined) {
                localVarQueryParameter['competitor'] = competitor;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateBib
         * @param {string} id 
         * @param {UpdateBibPayload} updateBibPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBib: async (id: string, updateBibPayload: UpdateBibPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBib', 'id', id)
            // verify required parameter 'updateBibPayload' is not null or undefined
            assertParamExists('updateBib', 'updateBibPayload', updateBibPayload)
            const localVarPath = `/bib/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBibPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BibApi - functional programming interface
 */
export const BibApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BibApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createBib
         * @param {CreateBibPayload} createBibPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBib(createBibPayload: CreateBibPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfBibEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBib(createBibPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BibApi.createBib']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteBib
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBib(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBib(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BibApi.deleteBib']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getAvailableBibs
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableBibs(event: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfBibEntityArray1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableBibs(event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BibApi.getAvailableBibs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getBibById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBibById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfBibEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBibById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BibApi.getBibById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getBibs
         * @param {string} [event] 
         * @param {string} [competitor] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBibs(event?: string, competitor?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfBibEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBibs(event, competitor, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BibApi.getBibs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateBib
         * @param {string} id 
         * @param {UpdateBibPayload} updateBibPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBib(id: string, updateBibPayload: UpdateBibPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfBibEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBib(id, updateBibPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BibApi.updateBib']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BibApi - factory interface
 */
export const BibApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BibApiFp(configuration)
    return {
        /**
         * 
         * @summary createBib
         * @param {CreateBibPayload} createBibPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBib(createBibPayload: CreateBibPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfBibEntity> {
            return localVarFp.createBib(createBibPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteBib
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBib(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteBib(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAvailableBibs
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBibs(event: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfBibEntityArray1> {
            return localVarFp.getAvailableBibs(event, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getBibById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBibById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfBibEntity> {
            return localVarFp.getBibById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getBibs
         * @param {string} [event] 
         * @param {string} [competitor] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBibs(event?: string, competitor?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfBibEntityArray> {
            return localVarFp.getBibs(event, competitor, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateBib
         * @param {string} id 
         * @param {UpdateBibPayload} updateBibPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBib(id: string, updateBibPayload: UpdateBibPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfBibEntity> {
            return localVarFp.updateBib(id, updateBibPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BibApi - object-oriented interface
 */
export class BibApi extends BaseAPI {
    /**
     * 
     * @summary createBib
     * @param {CreateBibPayload} createBibPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBib(createBibPayload: CreateBibPayload, options?: RawAxiosRequestConfig) {
        return BibApiFp(this.configuration).createBib(createBibPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteBib
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteBib(id: string, options?: RawAxiosRequestConfig) {
        return BibApiFp(this.configuration).deleteBib(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAvailableBibs
     * @param {string} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAvailableBibs(event: string, options?: RawAxiosRequestConfig) {
        return BibApiFp(this.configuration).getAvailableBibs(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getBibById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBibById(id: string, options?: RawAxiosRequestConfig) {
        return BibApiFp(this.configuration).getBibById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getBibs
     * @param {string} [event] 
     * @param {string} [competitor] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBibs(event?: string, competitor?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BibApiFp(this.configuration).getBibs(event, competitor, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateBib
     * @param {string} id 
     * @param {UpdateBibPayload} updateBibPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateBib(id: string, updateBibPayload: UpdateBibPayload, options?: RawAxiosRequestConfig) {
        return BibApiFp(this.configuration).updateBib(id, updateBibPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassApi - axios parameter creator
 */
export const ClassApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createClass
         * @param {CreateClassPayload} createClassPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass: async (createClassPayload: CreateClassPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createClassPayload' is not null or undefined
            assertParamExists('createClass', 'createClassPayload', createClassPayload)
            const localVarPath = `/class`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClassPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteClass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteClass', 'id', id)
            const localVarPath = `/class/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getClassById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClassById', 'id', id)
            const localVarPath = `/class/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getClassesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassesByEventId: async (event: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getClassesByEventId', 'event', event)
            const localVarPath = `/class`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateClass
         * @param {string} id 
         * @param {UpdateClassPayload} updateClassPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass: async (id: string, updateClassPayload: UpdateClassPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateClass', 'id', id)
            // verify required parameter 'updateClassPayload' is not null or undefined
            assertParamExists('updateClass', 'updateClassPayload', updateClassPayload)
            const localVarPath = `/class/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateClassPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassApi - functional programming interface
 */
export const ClassApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createClass
         * @param {CreateClassPayload} createClassPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClass(createClassPayload: CreateClassPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfClassEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClass(createClassPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.createClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteClass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClass(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClass(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.deleteClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getClassById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClassById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfClassEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClassById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getClassById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getClassesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClassesByEventId(event: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfClassEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClassesByEventId(event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.getClassesByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateClass
         * @param {string} id 
         * @param {UpdateClassPayload} updateClassPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClass(id: string, updateClassPayload: UpdateClassPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfClassEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClass(id, updateClassPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassApi.updateClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassApi - factory interface
 */
export const ClassApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassApiFp(configuration)
    return {
        /**
         * 
         * @summary createClass
         * @param {CreateClassPayload} createClassPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClass(createClassPayload: CreateClassPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfClassEntity> {
            return localVarFp.createClass(createClassPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteClass
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClass(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteClass(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getClassById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfClassEntity> {
            return localVarFp.getClassById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getClassesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassesByEventId(event: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfClassEntityArray> {
            return localVarFp.getClassesByEventId(event, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateClass
         * @param {string} id 
         * @param {UpdateClassPayload} updateClassPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClass(id: string, updateClassPayload: UpdateClassPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfClassEntity> {
            return localVarFp.updateClass(id, updateClassPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassApi - object-oriented interface
 */
export class ClassApi extends BaseAPI {
    /**
     * 
     * @summary createClass
     * @param {CreateClassPayload} createClassPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createClass(createClassPayload: CreateClassPayload, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).createClass(createClassPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteClass
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteClass(id: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).deleteClass(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getClassById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClassById(id: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getClassById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getClassesByEventId
     * @param {string} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClassesByEventId(event: string, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).getClassesByEventId(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateClass
     * @param {string} id 
     * @param {UpdateClassPayload} updateClassPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateClass(id: string, updateClassPayload: UpdateClassPayload, options?: RawAxiosRequestConfig) {
        return ClassApiFp(this.configuration).updateClass(id, updateClassPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompStatusApi - axios parameter creator
 */
export const CompStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getCompetitorStatus
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [competitorId] 
         * @param {string} [courseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorStatus: async (page?: number, pageSize?: number, competitorId?: string, courseId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (competitorId !== undefined) {
                localVarQueryParameter['competitorId'] = competitorId;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompStatusApi - functional programming interface
 */
export const CompStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary getCompetitorStatus
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [competitorId] 
         * @param {string} [courseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompetitorStatus(page?: number, pageSize?: number, competitorId?: string, courseId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorStatusEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompetitorStatus(page, pageSize, competitorId, courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompStatusApi.getCompetitorStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompStatusApi - factory interface
 */
export const CompStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompStatusApiFp(configuration)
    return {
        /**
         * 
         * @summary getCompetitorStatus
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [competitorId] 
         * @param {string} [courseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorStatus(page?: number, pageSize?: number, competitorId?: string, courseId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorStatusEntityArray> {
            return localVarFp.getCompetitorStatus(page, pageSize, competitorId, courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompStatusApi - object-oriented interface
 */
export class CompStatusApi extends BaseAPI {
    /**
     * 
     * @summary getCompetitorStatus
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [competitorId] 
     * @param {string} [courseId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCompetitorStatus(page?: number, pageSize?: number, competitorId?: string, courseId?: string, options?: RawAxiosRequestConfig) {
        return CompStatusApiFp(this.configuration).getCompetitorStatus(page, pageSize, competitorId, courseId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompetitorApi - axios parameter creator
 */
export const CompetitorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary batchCreateCompetitor
         * @param {BatchCreateCompetitorPayload} batchCreateCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateCompetitor: async (batchCreateCompetitorPayload: BatchCreateCompetitorPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchCreateCompetitorPayload' is not null or undefined
            assertParamExists('batchCreateCompetitor', 'batchCreateCompetitorPayload', batchCreateCompetitorPayload)
            const localVarPath = `/competitor/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchCreateCompetitorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createCompetitor
         * @param {CreateCompetitorPayload} createCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompetitor: async (createCompetitorPayload: CreateCompetitorPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCompetitorPayload' is not null or undefined
            assertParamExists('createCompetitor', 'createCompetitorPayload', createCompetitorPayload)
            const localVarPath = `/competitor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCompetitorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteCompetitor
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompetitor: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCompetitor', 'id', id)
            const localVarPath = `/competitor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCompetitorById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCompetitorById', 'id', id)
            const localVarPath = `/competitor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCompetitorsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorsByEventId: async (event: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getCompetitorsByEventId', 'event', event)
            const localVarPath = `/competitor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary searchCompetitors
         * @param {string} eventId 
         * @param {string} [cardNbr] 
         * @param {string} [name] 
         * @param {string} [bibNumber] 
         * @param {string} [teamName] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCompetitors: async (eventId: string, cardNbr?: string, name?: string, bibNumber?: string, teamName?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('searchCompetitors', 'eventId', eventId)
            const localVarPath = `/competitor/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (cardNbr !== undefined) {
                localVarQueryParameter['cardNbr'] = cardNbr;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (bibNumber !== undefined) {
                localVarQueryParameter['bibNumber'] = bibNumber;
            }

            if (teamName !== undefined) {
                localVarQueryParameter['teamName'] = teamName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCompetitor
         * @param {string} id 
         * @param {UpdateCompetitorPayload} updateCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompetitor: async (id: string, updateCompetitorPayload: UpdateCompetitorPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCompetitor', 'id', id)
            // verify required parameter 'updateCompetitorPayload' is not null or undefined
            assertParamExists('updateCompetitor', 'updateCompetitorPayload', updateCompetitorPayload)
            const localVarPath = `/competitor/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCompetitorPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompetitorApi - functional programming interface
 */
export const CompetitorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompetitorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary batchCreateCompetitor
         * @param {BatchCreateCompetitorPayload} batchCreateCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchCreateCompetitor(batchCreateCompetitorPayload: BatchCreateCompetitorPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfBatchCreateCompetitorResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchCreateCompetitor(batchCreateCompetitorPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitorApi.batchCreateCompetitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary createCompetitor
         * @param {CreateCompetitorPayload} createCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompetitor(createCompetitorPayload: CreateCompetitorPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompetitor(createCompetitorPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitorApi.createCompetitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteCompetitor
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompetitor(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompetitor(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitorApi.deleteCompetitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCompetitorById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompetitorById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorExtEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompetitorById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitorApi.getCompetitorById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCompetitorsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompetitorsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorExtEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompetitorsByEventId(event, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitorApi.getCompetitorsByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary searchCompetitors
         * @param {string} eventId 
         * @param {string} [cardNbr] 
         * @param {string} [name] 
         * @param {string} [bibNumber] 
         * @param {string} [teamName] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCompetitors(eventId: string, cardNbr?: string, name?: string, bibNumber?: string, teamName?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorExtEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCompetitors(eventId, cardNbr, name, bibNumber, teamName, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitorApi.searchCompetitors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateCompetitor
         * @param {string} id 
         * @param {UpdateCompetitorPayload} updateCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompetitor(id: string, updateCompetitorPayload: UpdateCompetitorPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorExtEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompetitor(id, updateCompetitorPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompetitorApi.updateCompetitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompetitorApi - factory interface
 */
export const CompetitorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompetitorApiFp(configuration)
    return {
        /**
         * 
         * @summary batchCreateCompetitor
         * @param {BatchCreateCompetitorPayload} batchCreateCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateCompetitor(batchCreateCompetitorPayload: BatchCreateCompetitorPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfBatchCreateCompetitorResult> {
            return localVarFp.batchCreateCompetitor(batchCreateCompetitorPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createCompetitor
         * @param {CreateCompetitorPayload} createCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompetitor(createCompetitorPayload: CreateCompetitorPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorEntity> {
            return localVarFp.createCompetitor(createCompetitorPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteCompetitor
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompetitor(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteCompetitor(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCompetitorById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorExtEntity> {
            return localVarFp.getCompetitorById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCompetitorsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorExtEntityArray> {
            return localVarFp.getCompetitorsByEventId(event, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary searchCompetitors
         * @param {string} eventId 
         * @param {string} [cardNbr] 
         * @param {string} [name] 
         * @param {string} [bibNumber] 
         * @param {string} [teamName] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCompetitors(eventId: string, cardNbr?: string, name?: string, bibNumber?: string, teamName?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorExtEntityArray> {
            return localVarFp.searchCompetitors(eventId, cardNbr, name, bibNumber, teamName, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateCompetitor
         * @param {string} id 
         * @param {UpdateCompetitorPayload} updateCompetitorPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompetitor(id: string, updateCompetitorPayload: UpdateCompetitorPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorExtEntity> {
            return localVarFp.updateCompetitor(id, updateCompetitorPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompetitorApi - object-oriented interface
 */
export class CompetitorApi extends BaseAPI {
    /**
     * 
     * @summary batchCreateCompetitor
     * @param {BatchCreateCompetitorPayload} batchCreateCompetitorPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public batchCreateCompetitor(batchCreateCompetitorPayload: BatchCreateCompetitorPayload, options?: RawAxiosRequestConfig) {
        return CompetitorApiFp(this.configuration).batchCreateCompetitor(batchCreateCompetitorPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createCompetitor
     * @param {CreateCompetitorPayload} createCompetitorPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCompetitor(createCompetitorPayload: CreateCompetitorPayload, options?: RawAxiosRequestConfig) {
        return CompetitorApiFp(this.configuration).createCompetitor(createCompetitorPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteCompetitor
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCompetitor(id: string, options?: RawAxiosRequestConfig) {
        return CompetitorApiFp(this.configuration).deleteCompetitor(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCompetitorById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCompetitorById(id: string, options?: RawAxiosRequestConfig) {
        return CompetitorApiFp(this.configuration).getCompetitorById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCompetitorsByEventId
     * @param {string} event 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCompetitorsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return CompetitorApiFp(this.configuration).getCompetitorsByEventId(event, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary searchCompetitors
     * @param {string} eventId 
     * @param {string} [cardNbr] 
     * @param {string} [name] 
     * @param {string} [bibNumber] 
     * @param {string} [teamName] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchCompetitors(eventId: string, cardNbr?: string, name?: string, bibNumber?: string, teamName?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return CompetitorApiFp(this.configuration).searchCompetitors(eventId, cardNbr, name, bibNumber, teamName, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateCompetitor
     * @param {string} id 
     * @param {UpdateCompetitorPayload} updateCompetitorPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCompetitor(id: string, updateCompetitorPayload: UpdateCompetitorPayload, options?: RawAxiosRequestConfig) {
        return CompetitorApiFp(this.configuration).updateCompetitor(id, updateCompetitorPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ControlPointApi - axios parameter creator
 */
export const ControlPointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary bindControlStation
         * @param {string} id 
         * @param {BindControlStationPayload} bindControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindControlStation: async (id: string, bindControlStationPayload: BindControlStationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bindControlStation', 'id', id)
            // verify required parameter 'bindControlStationPayload' is not null or undefined
            assertParamExists('bindControlStation', 'bindControlStationPayload', bindControlStationPayload)
            const localVarPath = `/controlpoint/{id}/bindstation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bindControlStationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createControlPoint
         * @param {CreateControlPointPayload} createControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createControlPoint: async (createControlPointPayload: CreateControlPointPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createControlPointPayload' is not null or undefined
            assertParamExists('createControlPoint', 'createControlPointPayload', createControlPointPayload)
            const localVarPath = `/controlpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createControlPointPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteControlPoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteControlPoint: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteControlPoint', 'id', id)
            const localVarPath = `/controlpoint/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBindControlStation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBindControlStation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBindControlStation', 'id', id)
            const localVarPath = `/controlpoint/{id}/bindstation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getControlPointById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlPointById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getControlPointById', 'id', id)
            const localVarPath = `/controlpoint/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unbindControlStation
         * @param {string} id 
         * @param {UnbindControlStationPayload} unbindControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindControlStation: async (id: string, unbindControlStationPayload: UnbindControlStationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unbindControlStation', 'id', id)
            // verify required parameter 'unbindControlStationPayload' is not null or undefined
            assertParamExists('unbindControlStation', 'unbindControlStationPayload', unbindControlStationPayload)
            const localVarPath = `/controlpoint/{id}/bindstation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unbindControlStationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateControlPoint
         * @param {string} id 
         * @param {UpdateControlPointPayload} updateControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlPoint: async (id: string, updateControlPointPayload: UpdateControlPointPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateControlPoint', 'id', id)
            // verify required parameter 'updateControlPointPayload' is not null or undefined
            assertParamExists('updateControlPoint', 'updateControlPointPayload', updateControlPointPayload)
            const localVarPath = `/controlpoint/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateControlPointPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControlPointApi - functional programming interface
 */
export const ControlPointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControlPointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary bindControlStation
         * @param {string} id 
         * @param {BindControlStationPayload} bindControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindControlStation(id: string, bindControlStationPayload: BindControlStationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlBindingEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindControlStation(id, bindControlStationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlPointApi.bindControlStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary createControlPoint
         * @param {CreateControlPointPayload} createControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createControlPoint(createControlPointPayload: CreateControlPointPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlPointEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createControlPoint(createControlPointPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlPointApi.createControlPoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteControlPoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteControlPoint(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteControlPoint(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlPointApi.deleteControlPoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getBindControlStation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBindControlStation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlStationEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBindControlStation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlPointApi.getBindControlStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getControlPointById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlPointById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlPointEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlPointById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlPointApi.getControlPointById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary unbindControlStation
         * @param {string} id 
         * @param {UnbindControlStationPayload} unbindControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbindControlStation(id: string, unbindControlStationPayload: UnbindControlStationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbindControlStation(id, unbindControlStationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlPointApi.unbindControlStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateControlPoint
         * @param {string} id 
         * @param {UpdateControlPointPayload} updateControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateControlPoint(id: string, updateControlPointPayload: UpdateControlPointPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlPointEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateControlPoint(id, updateControlPointPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlPointApi.updateControlPoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ControlPointApi - factory interface
 */
export const ControlPointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControlPointApiFp(configuration)
    return {
        /**
         * 
         * @summary bindControlStation
         * @param {string} id 
         * @param {BindControlStationPayload} bindControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindControlStation(id: string, bindControlStationPayload: BindControlStationPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlBindingEntity> {
            return localVarFp.bindControlStation(id, bindControlStationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createControlPoint
         * @param {CreateControlPointPayload} createControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createControlPoint(createControlPointPayload: CreateControlPointPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlPointEntity> {
            return localVarFp.createControlPoint(createControlPointPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteControlPoint
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteControlPoint(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteControlPoint(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getBindControlStation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBindControlStation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlStationEntityArray> {
            return localVarFp.getBindControlStation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getControlPointById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlPointById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlPointEntity> {
            return localVarFp.getControlPointById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unbindControlStation
         * @param {string} id 
         * @param {UnbindControlStationPayload} unbindControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbindControlStation(id: string, unbindControlStationPayload: UnbindControlStationPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.unbindControlStation(id, unbindControlStationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateControlPoint
         * @param {string} id 
         * @param {UpdateControlPointPayload} updateControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlPoint(id: string, updateControlPointPayload: UpdateControlPointPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlPointEntity> {
            return localVarFp.updateControlPoint(id, updateControlPointPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControlPointApi - object-oriented interface
 */
export class ControlPointApi extends BaseAPI {
    /**
     * 
     * @summary bindControlStation
     * @param {string} id 
     * @param {BindControlStationPayload} bindControlStationPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bindControlStation(id: string, bindControlStationPayload: BindControlStationPayload, options?: RawAxiosRequestConfig) {
        return ControlPointApiFp(this.configuration).bindControlStation(id, bindControlStationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createControlPoint
     * @param {CreateControlPointPayload} createControlPointPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createControlPoint(createControlPointPayload: CreateControlPointPayload, options?: RawAxiosRequestConfig) {
        return ControlPointApiFp(this.configuration).createControlPoint(createControlPointPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteControlPoint
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteControlPoint(id: string, options?: RawAxiosRequestConfig) {
        return ControlPointApiFp(this.configuration).deleteControlPoint(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getBindControlStation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBindControlStation(id: string, options?: RawAxiosRequestConfig) {
        return ControlPointApiFp(this.configuration).getBindControlStation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getControlPointById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getControlPointById(id: string, options?: RawAxiosRequestConfig) {
        return ControlPointApiFp(this.configuration).getControlPointById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unbindControlStation
     * @param {string} id 
     * @param {UnbindControlStationPayload} unbindControlStationPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unbindControlStation(id: string, unbindControlStationPayload: UnbindControlStationPayload, options?: RawAxiosRequestConfig) {
        return ControlPointApiFp(this.configuration).unbindControlStation(id, unbindControlStationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateControlPoint
     * @param {string} id 
     * @param {UpdateControlPointPayload} updateControlPointPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateControlPoint(id: string, updateControlPointPayload: UpdateControlPointPayload, options?: RawAxiosRequestConfig) {
        return ControlPointApiFp(this.configuration).updateControlPoint(id, updateControlPointPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseApi - axios parameter creator
 */
export const CourseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCourse
         * @param {CreateCoursePayload} createCoursePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourse: async (createCoursePayload: CreateCoursePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCoursePayload' is not null or undefined
            assertParamExists('createCourse', 'createCoursePayload', createCoursePayload)
            const localVarPath = `/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCoursePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteCourse
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCourse', 'id', id)
            const localVarPath = `/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCourseById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseById', 'id', id)
            const localVarPath = `/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCourses
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses: async (stage: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stage' is not null or undefined
            assertParamExists('getCourses', 'stage', stage)
            const localVarPath = `/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stage !== undefined) {
                localVarQueryParameter['stage'] = stage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCourse
         * @param {string} id 
         * @param {UpdateCoursePayload} updateCoursePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse: async (id: string, updateCoursePayload: UpdateCoursePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCourse', 'id', id)
            // verify required parameter 'updateCoursePayload' is not null or undefined
            assertParamExists('updateCourse', 'updateCoursePayload', updateCoursePayload)
            const localVarPath = `/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCoursePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseApi - functional programming interface
 */
export const CourseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createCourse
         * @param {CreateCoursePayload} createCoursePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourse(createCoursePayload: CreateCoursePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourse(createCoursePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.createCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteCourse
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourse(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourse(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.deleteCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCourseById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.getCourseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCourses
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourses(stage: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourses(stage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.getCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateCourse
         * @param {string} id 
         * @param {UpdateCoursePayload} updateCoursePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourse(id: string, updateCoursePayload: UpdateCoursePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourse(id, updateCoursePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.updateCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseApi - factory interface
 */
export const CourseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseApiFp(configuration)
    return {
        /**
         * 
         * @summary createCourse
         * @param {CreateCoursePayload} createCoursePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourse(createCoursePayload: CreateCoursePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseEntity> {
            return localVarFp.createCourse(createCoursePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteCourse
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourse(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteCourse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCourseById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseEntity> {
            return localVarFp.getCourseById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCourses
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourses(stage: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseEntityArray> {
            return localVarFp.getCourses(stage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateCourse
         * @param {string} id 
         * @param {UpdateCoursePayload} updateCoursePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourse(id: string, updateCoursePayload: UpdateCoursePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseEntity> {
            return localVarFp.updateCourse(id, updateCoursePayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseApi - object-oriented interface
 */
export class CourseApi extends BaseAPI {
    /**
     * 
     * @summary createCourse
     * @param {CreateCoursePayload} createCoursePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCourse(createCoursePayload: CreateCoursePayload, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).createCourse(createCoursePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteCourse
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCourse(id: string, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).deleteCourse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCourseById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCourseById(id: string, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).getCourseById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCourses
     * @param {string} stage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCourses(stage: string, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).getCourses(stage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateCourse
     * @param {string} id 
     * @param {UpdateCoursePayload} updateCoursePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCourse(id: string, updateCoursePayload: UpdateCoursePayload, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).updateCourse(id, updateCoursePayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseRuleApi - axios parameter creator
 */
export const CourseRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCourseRule
         * @param {CreateCourseRulePayload} createCourseRulePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseRule: async (createCourseRulePayload: CreateCourseRulePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCourseRulePayload' is not null or undefined
            assertParamExists('createCourseRule', 'createCourseRulePayload', createCourseRulePayload)
            const localVarPath = `/courserule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseRulePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteCourseRule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseRule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCourseRule', 'id', id)
            const localVarPath = `/courserule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCourseRuleById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseRuleById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCourseRuleById', 'id', id)
            const localVarPath = `/courserule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCourseRulesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseRulesByEventId: async (event: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getCourseRulesByEventId', 'event', event)
            const localVarPath = `/courserule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCourseRule
         * @param {string} id 
         * @param {UpdateCourseRulePayload} updateCourseRulePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseRule: async (id: string, updateCourseRulePayload: UpdateCourseRulePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCourseRule', 'id', id)
            // verify required parameter 'updateCourseRulePayload' is not null or undefined
            assertParamExists('updateCourseRule', 'updateCourseRulePayload', updateCourseRulePayload)
            const localVarPath = `/courserule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCourseRulePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseRuleApi - functional programming interface
 */
export const CourseRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createCourseRule
         * @param {CreateCourseRulePayload} createCourseRulePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCourseRule(createCourseRulePayload: CreateCourseRulePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseRuleEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCourseRule(createCourseRulePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseRuleApi.createCourseRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteCourseRule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCourseRule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCourseRule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseRuleApi.deleteCourseRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCourseRuleById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseRuleById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseRuleEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseRuleById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseRuleApi.getCourseRuleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCourseRulesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourseRulesByEventId(event: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseRuleEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourseRulesByEventId(event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseRuleApi.getCourseRulesByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateCourseRule
         * @param {string} id 
         * @param {UpdateCourseRulePayload} updateCourseRulePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCourseRule(id: string, updateCourseRulePayload: UpdateCourseRulePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseRuleEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCourseRule(id, updateCourseRulePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseRuleApi.updateCourseRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseRuleApi - factory interface
 */
export const CourseRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary createCourseRule
         * @param {CreateCourseRulePayload} createCourseRulePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCourseRule(createCourseRulePayload: CreateCourseRulePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseRuleEntity> {
            return localVarFp.createCourseRule(createCourseRulePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteCourseRule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCourseRule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteCourseRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCourseRuleById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseRuleById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseRuleEntity> {
            return localVarFp.getCourseRuleById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCourseRulesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourseRulesByEventId(event: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseRuleEntityArray> {
            return localVarFp.getCourseRulesByEventId(event, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateCourseRule
         * @param {string} id 
         * @param {UpdateCourseRulePayload} updateCourseRulePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCourseRule(id: string, updateCourseRulePayload: UpdateCourseRulePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseRuleEntity> {
            return localVarFp.updateCourseRule(id, updateCourseRulePayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseRuleApi - object-oriented interface
 */
export class CourseRuleApi extends BaseAPI {
    /**
     * 
     * @summary createCourseRule
     * @param {CreateCourseRulePayload} createCourseRulePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCourseRule(createCourseRulePayload: CreateCourseRulePayload, options?: RawAxiosRequestConfig) {
        return CourseRuleApiFp(this.configuration).createCourseRule(createCourseRulePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteCourseRule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCourseRule(id: string, options?: RawAxiosRequestConfig) {
        return CourseRuleApiFp(this.configuration).deleteCourseRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCourseRuleById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCourseRuleById(id: string, options?: RawAxiosRequestConfig) {
        return CourseRuleApiFp(this.configuration).getCourseRuleById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCourseRulesByEventId
     * @param {string} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCourseRulesByEventId(event: string, options?: RawAxiosRequestConfig) {
        return CourseRuleApiFp(this.configuration).getCourseRulesByEventId(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateCourseRule
     * @param {string} id 
     * @param {UpdateCourseRulePayload} updateCourseRulePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCourseRule(id: string, updateCourseRulePayload: UpdateCourseRulePayload, options?: RawAxiosRequestConfig) {
        return CourseRuleApiFp(this.configuration).updateCourseRule(id, updateCourseRulePayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceApi - axios parameter creator
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createControlStation
         * @param {CreateControlStationPayload} createControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createControlStation: async (createControlStationPayload: CreateControlStationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createControlStationPayload' is not null or undefined
            assertParamExists('createControlStation', 'createControlStationPayload', createControlStationPayload)
            const localVarPath = `/device/control-station`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createControlStationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteControlStation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteControlStation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteControlStation', 'id', id)
            const localVarPath = `/device/control-station/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllControlStations
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlStations: async (status: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getAllControlStations', 'status', status)
            const localVarPath = `/device/control-station`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getControlStationById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlStationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getControlStationById', 'id', id)
            const localVarPath = `/device/control-station/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateControlStation
         * @param {string} id 
         * @param {UpdateControlStationPayload} updateControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlStation: async (id: string, updateControlStationPayload: UpdateControlStationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateControlStation', 'id', id)
            // verify required parameter 'updateControlStationPayload' is not null or undefined
            assertParamExists('updateControlStation', 'updateControlStationPayload', updateControlStationPayload)
            const localVarPath = `/device/control-station/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateControlStationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createControlStation
         * @param {CreateControlStationPayload} createControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createControlStation(createControlStationPayload: CreateControlStationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlStationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createControlStation(createControlStationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.createControlStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteControlStation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteControlStation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteControlStation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.deleteControlStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getAllControlStations
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllControlStations(status: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlStationEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllControlStations(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.getAllControlStations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getControlStationById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlStationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlStationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlStationById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.getControlStationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateControlStation
         * @param {string} id 
         * @param {UpdateControlStationPayload} updateControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateControlStation(id: string, updateControlStationPayload: UpdateControlStationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfControlStationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateControlStation(id, updateControlStationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.updateControlStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeviceApi - factory interface
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceApiFp(configuration)
    return {
        /**
         * 
         * @summary createControlStation
         * @param {CreateControlStationPayload} createControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createControlStation(createControlStationPayload: CreateControlStationPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlStationEntity> {
            return localVarFp.createControlStation(createControlStationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteControlStation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteControlStation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteControlStation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllControlStations
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllControlStations(status: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlStationEntityArray> {
            return localVarFp.getAllControlStations(status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getControlStationById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlStationById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlStationEntity> {
            return localVarFp.getControlStationById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateControlStation
         * @param {string} id 
         * @param {UpdateControlStationPayload} updateControlStationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlStation(id: string, updateControlStationPayload: UpdateControlStationPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfControlStationEntity> {
            return localVarFp.updateControlStation(id, updateControlStationPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 */
export class DeviceApi extends BaseAPI {
    /**
     * 
     * @summary createControlStation
     * @param {CreateControlStationPayload} createControlStationPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createControlStation(createControlStationPayload: CreateControlStationPayload, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).createControlStation(createControlStationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteControlStation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteControlStation(id: string, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).deleteControlStation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllControlStations
     * @param {string} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllControlStations(status: string, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).getAllControlStations(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getControlStationById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getControlStationById(id: string, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).getControlStationById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateControlStation
     * @param {string} id 
     * @param {UpdateControlStationPayload} updateControlStationPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateControlStation(id: string, updateControlStationPayload: UpdateControlStationPayload, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).updateControlStation(id, updateControlStationPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventApi - axios parameter creator
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createEvent
         * @param {CreateEventPayload} createEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (createEventPayload: CreateEventPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventPayload' is not null or undefined
            assertParamExists('createEvent', 'createEventPayload', createEventPayload)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteEvent
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getEventById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEventById', 'id', id)
            const localVarPath = `/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateEvent
         * @param {string} id 
         * @param {UpdateEventPayload} updateEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (id: string, updateEventPayload: UpdateEventPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            // verify required parameter 'updateEventPayload' is not null or undefined
            assertParamExists('updateEvent', 'updateEventPayload', updateEventPayload)
            const localVarPath = `/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createEvent
         * @param {CreateEventPayload} createEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(createEventPayload: CreateEventPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfEventEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(createEventPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteEvent
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.deleteEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getAllEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfEventEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getAllEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getEventById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfEventEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getEventById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateEvent
         * @param {string} id 
         * @param {UpdateEventPayload} updateEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(id: string, updateEventPayload: UpdateEventPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfEventEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, updateEventPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventApi - factory interface
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary createEvent
         * @param {CreateEventPayload} createEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(createEventPayload: CreateEventPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfEventEntity> {
            return localVarFp.createEvent(createEventPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteEvent
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllEvents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents(options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfEventEntityArray> {
            return localVarFp.getAllEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getEventById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfEventEntity> {
            return localVarFp.getEventById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateEvent
         * @param {string} id 
         * @param {UpdateEventPayload} updateEventPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(id: string, updateEventPayload: UpdateEventPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfEventEntity> {
            return localVarFp.updateEvent(id, updateEventPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary createEvent
     * @param {CreateEventPayload} createEventPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEvent(createEventPayload: CreateEventPayload, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).createEvent(createEventPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteEvent
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteEvent(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllEvents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllEvents(options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getAllEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getEventById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getEventById(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateEvent
     * @param {string} id 
     * @param {UpdateEventPayload} updateEventPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateEvent(id: string, updateEventPayload: UpdateEventPayload, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).updateEvent(id, updateEventPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FingerCardApi - axios parameter creator
 */
export const FingerCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createFingerCard
         * @param {CreateFingerCardPayload} createFingerCardPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFingerCard: async (createFingerCardPayload: CreateFingerCardPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFingerCardPayload' is not null or undefined
            assertParamExists('createFingerCard', 'createFingerCardPayload', createFingerCardPayload)
            const localVarPath = `/finger-card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFingerCardPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteFingerCard
         * @param {string} event 
         * @param {string} cardNbr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFingerCard: async (event: string, cardNbr: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('deleteFingerCard', 'event', event)
            // verify required parameter 'cardNbr' is not null or undefined
            assertParamExists('deleteFingerCard', 'cardNbr', cardNbr)
            const localVarPath = `/finger-card/{cardNbr}`
                .replace(`{${"cardNbr"}}`, encodeURIComponent(String(cardNbr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFingerCardById
         * @param {string} event 
         * @param {string} cardNbr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFingerCardById: async (event: string, cardNbr: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getFingerCardById', 'event', event)
            // verify required parameter 'cardNbr' is not null or undefined
            assertParamExists('getFingerCardById', 'cardNbr', cardNbr)
            const localVarPath = `/finger-card/{cardNbr}`
                .replace(`{${"cardNbr"}}`, encodeURIComponent(String(cardNbr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFingerCards
         * @param {string} event 
         * @param {string} cardnbr 
         * @param {string} competitor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFingerCards: async (event: string, cardnbr: string, competitor: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getFingerCards', 'event', event)
            // verify required parameter 'cardnbr' is not null or undefined
            assertParamExists('getFingerCards', 'cardnbr', cardnbr)
            // verify required parameter 'competitor' is not null or undefined
            assertParamExists('getFingerCards', 'competitor', competitor)
            const localVarPath = `/finger-card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (cardnbr !== undefined) {
                localVarQueryParameter['cardnbr'] = cardnbr;
            }

            if (competitor !== undefined) {
                localVarQueryParameter['competitor'] = competitor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFingerCardsAvailable
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFingerCardsAvailable: async (event: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getFingerCardsAvailable', 'event', event)
            const localVarPath = `/finger-card/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateFingerCard
         * @param {string} cardNbr 
         * @param {UpdateFingerCardPayload} updateFingerCardPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFingerCard: async (cardNbr: string, updateFingerCardPayload: UpdateFingerCardPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardNbr' is not null or undefined
            assertParamExists('updateFingerCard', 'cardNbr', cardNbr)
            // verify required parameter 'updateFingerCardPayload' is not null or undefined
            assertParamExists('updateFingerCard', 'updateFingerCardPayload', updateFingerCardPayload)
            const localVarPath = `/finger-card/{cardNbr}`
                .replace(`{${"cardNbr"}}`, encodeURIComponent(String(cardNbr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFingerCardPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FingerCardApi - functional programming interface
 */
export const FingerCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FingerCardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createFingerCard
         * @param {CreateFingerCardPayload} createFingerCardPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFingerCard(createFingerCardPayload: CreateFingerCardPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfFingerCardEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFingerCard(createFingerCardPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerCardApi.createFingerCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteFingerCard
         * @param {string} event 
         * @param {string} cardNbr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFingerCard(event: string, cardNbr: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFingerCard(event, cardNbr, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerCardApi.deleteFingerCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getFingerCardById
         * @param {string} event 
         * @param {string} cardNbr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFingerCardById(event: string, cardNbr: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfFingerCardEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFingerCardById(event, cardNbr, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerCardApi.getFingerCardById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getFingerCards
         * @param {string} event 
         * @param {string} cardnbr 
         * @param {string} competitor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFingerCards(event: string, cardnbr: string, competitor: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfFingerCardEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFingerCards(event, cardnbr, competitor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerCardApi.getFingerCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getFingerCardsAvailable
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFingerCardsAvailable(event: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfFingerCardEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFingerCardsAvailable(event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerCardApi.getFingerCardsAvailable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateFingerCard
         * @param {string} cardNbr 
         * @param {UpdateFingerCardPayload} updateFingerCardPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFingerCard(cardNbr: string, updateFingerCardPayload: UpdateFingerCardPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfFingerCardEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFingerCard(cardNbr, updateFingerCardPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerCardApi.updateFingerCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FingerCardApi - factory interface
 */
export const FingerCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FingerCardApiFp(configuration)
    return {
        /**
         * 
         * @summary createFingerCard
         * @param {CreateFingerCardPayload} createFingerCardPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFingerCard(createFingerCardPayload: CreateFingerCardPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfFingerCardEntity> {
            return localVarFp.createFingerCard(createFingerCardPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteFingerCard
         * @param {string} event 
         * @param {string} cardNbr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFingerCard(event: string, cardNbr: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteFingerCard(event, cardNbr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getFingerCardById
         * @param {string} event 
         * @param {string} cardNbr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFingerCardById(event: string, cardNbr: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfFingerCardEntity> {
            return localVarFp.getFingerCardById(event, cardNbr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getFingerCards
         * @param {string} event 
         * @param {string} cardnbr 
         * @param {string} competitor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFingerCards(event: string, cardnbr: string, competitor: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfFingerCardEntityArray> {
            return localVarFp.getFingerCards(event, cardnbr, competitor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getFingerCardsAvailable
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFingerCardsAvailable(event: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfFingerCardEntityArray> {
            return localVarFp.getFingerCardsAvailable(event, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateFingerCard
         * @param {string} cardNbr 
         * @param {UpdateFingerCardPayload} updateFingerCardPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFingerCard(cardNbr: string, updateFingerCardPayload: UpdateFingerCardPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfFingerCardEntity> {
            return localVarFp.updateFingerCard(cardNbr, updateFingerCardPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FingerCardApi - object-oriented interface
 */
export class FingerCardApi extends BaseAPI {
    /**
     * 
     * @summary createFingerCard
     * @param {CreateFingerCardPayload} createFingerCardPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFingerCard(createFingerCardPayload: CreateFingerCardPayload, options?: RawAxiosRequestConfig) {
        return FingerCardApiFp(this.configuration).createFingerCard(createFingerCardPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteFingerCard
     * @param {string} event 
     * @param {string} cardNbr 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFingerCard(event: string, cardNbr: string, options?: RawAxiosRequestConfig) {
        return FingerCardApiFp(this.configuration).deleteFingerCard(event, cardNbr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getFingerCardById
     * @param {string} event 
     * @param {string} cardNbr 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFingerCardById(event: string, cardNbr: string, options?: RawAxiosRequestConfig) {
        return FingerCardApiFp(this.configuration).getFingerCardById(event, cardNbr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getFingerCards
     * @param {string} event 
     * @param {string} cardnbr 
     * @param {string} competitor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFingerCards(event: string, cardnbr: string, competitor: string, options?: RawAxiosRequestConfig) {
        return FingerCardApiFp(this.configuration).getFingerCards(event, cardnbr, competitor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getFingerCardsAvailable
     * @param {string} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFingerCardsAvailable(event: string, options?: RawAxiosRequestConfig) {
        return FingerCardApiFp(this.configuration).getFingerCardsAvailable(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateFingerCard
     * @param {string} cardNbr 
     * @param {UpdateFingerCardPayload} updateFingerCardPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFingerCard(cardNbr: string, updateFingerCardPayload: UpdateFingerCardPayload, options?: RawAxiosRequestConfig) {
        return FingerCardApiFp(this.configuration).updateFingerCard(cardNbr, updateFingerCardPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LiveApi - axios parameter creator
 */
export const LiveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary generateTrackingBoard
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTrackingBoard: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('generateTrackingBoard', 'courseId', courseId)
            const localVarPath = `/live/tracking-board/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTrackBoardEvents
         * @param {string} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackBoardEvents: async (eventId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/live/track-board/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTrackingBoard
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingBoard: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('getTrackingBoard', 'courseId', courseId)
            const localVarPath = `/live/tracking-board/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveApi - functional programming interface
 */
export const LiveApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary generateTrackingBoard
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTrackingBoard(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseTrackingBoardEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTrackingBoard(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.generateTrackingBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTrackBoardEvents
         * @param {string} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackBoardEvents(eventId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTrackBoardEventEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackBoardEvents(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.getTrackBoardEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTrackingBoard
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackingBoard(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseTrackingBoardEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackingBoard(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LiveApi.getTrackingBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LiveApi - factory interface
 */
export const LiveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveApiFp(configuration)
    return {
        /**
         * 
         * @summary generateTrackingBoard
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTrackingBoard(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseTrackingBoardEntity> {
            return localVarFp.generateTrackingBoard(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTrackBoardEvents
         * @param {string} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackBoardEvents(eventId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTrackBoardEventEntityArray> {
            return localVarFp.getTrackBoardEvents(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTrackingBoard
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingBoard(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseTrackingBoardEntity> {
            return localVarFp.getTrackingBoard(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveApi - object-oriented interface
 */
export class LiveApi extends BaseAPI {
    /**
     * 
     * @summary generateTrackingBoard
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateTrackingBoard(courseId: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).generateTrackingBoard(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTrackBoardEvents
     * @param {string} [eventId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTrackBoardEvents(eventId?: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).getTrackBoardEvents(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTrackingBoard
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTrackingBoard(courseId: string, options?: RawAxiosRequestConfig) {
        return LiveApiFp(this.configuration).getTrackingBoard(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PunchApi - axios parameter creator
 */
export const PunchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createPunchRecordFromFingerCard
         * @param {CreatePunchRecordPayload} createPunchRecordPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPunchRecordFromFingerCard: async (createPunchRecordPayload: CreatePunchRecordPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPunchRecordPayload' is not null or undefined
            assertParamExists('createPunchRecordFromFingerCard', 'createPunchRecordPayload', createPunchRecordPayload)
            const localVarPath = `/punch/finger-card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPunchRecordPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPunchRecords
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [competitorId] 
         * @param {string} [courseId] 
         * @param {string} [controlId] 
         * @param {string} [deviceId] 
         * @param {GetPunchRecordsSortByEnum} [sortBy] 排序字段
         * @param {GetPunchRecordsSortOrderEnum} [sortOrder] 排序方向
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPunchRecords: async (page?: number, pageSize?: number, competitorId?: string, courseId?: string, controlId?: string, deviceId?: string, sortBy?: GetPunchRecordsSortByEnum, sortOrder?: GetPunchRecordsSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/punch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (competitorId !== undefined) {
                localVarQueryParameter['competitorId'] = competitorId;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }

            if (controlId !== undefined) {
                localVarQueryParameter['controlId'] = controlId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PunchApi - functional programming interface
 */
export const PunchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PunchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createPunchRecordFromFingerCard
         * @param {CreatePunchRecordPayload} createPunchRecordPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPunchRecordFromFingerCard(createPunchRecordPayload: CreatePunchRecordPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfObjectEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPunchRecordFromFingerCard(createPunchRecordPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PunchApi.createPunchRecordFromFingerCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getPunchRecords
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [competitorId] 
         * @param {string} [courseId] 
         * @param {string} [controlId] 
         * @param {string} [deviceId] 
         * @param {GetPunchRecordsSortByEnum} [sortBy] 排序字段
         * @param {GetPunchRecordsSortOrderEnum} [sortOrder] 排序方向
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPunchRecords(page?: number, pageSize?: number, competitorId?: string, courseId?: string, controlId?: string, deviceId?: string, sortBy?: GetPunchRecordsSortByEnum, sortOrder?: GetPunchRecordsSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfPunchRecordEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPunchRecords(page, pageSize, competitorId, courseId, controlId, deviceId, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PunchApi.getPunchRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PunchApi - factory interface
 */
export const PunchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PunchApiFp(configuration)
    return {
        /**
         * 
         * @summary createPunchRecordFromFingerCard
         * @param {CreatePunchRecordPayload} createPunchRecordPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPunchRecordFromFingerCard(createPunchRecordPayload: CreatePunchRecordPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfObjectEntityArray> {
            return localVarFp.createPunchRecordFromFingerCard(createPunchRecordPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPunchRecords
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [competitorId] 
         * @param {string} [courseId] 
         * @param {string} [controlId] 
         * @param {string} [deviceId] 
         * @param {GetPunchRecordsSortByEnum} [sortBy] 排序字段
         * @param {GetPunchRecordsSortOrderEnum} [sortOrder] 排序方向
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPunchRecords(page?: number, pageSize?: number, competitorId?: string, courseId?: string, controlId?: string, deviceId?: string, sortBy?: GetPunchRecordsSortByEnum, sortOrder?: GetPunchRecordsSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfPunchRecordEntityArray> {
            return localVarFp.getPunchRecords(page, pageSize, competitorId, courseId, controlId, deviceId, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PunchApi - object-oriented interface
 */
export class PunchApi extends BaseAPI {
    /**
     * 
     * @summary createPunchRecordFromFingerCard
     * @param {CreatePunchRecordPayload} createPunchRecordPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPunchRecordFromFingerCard(createPunchRecordPayload: CreatePunchRecordPayload, options?: RawAxiosRequestConfig) {
        return PunchApiFp(this.configuration).createPunchRecordFromFingerCard(createPunchRecordPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPunchRecords
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [competitorId] 
     * @param {string} [courseId] 
     * @param {string} [controlId] 
     * @param {string} [deviceId] 
     * @param {GetPunchRecordsSortByEnum} [sortBy] 排序字段
     * @param {GetPunchRecordsSortOrderEnum} [sortOrder] 排序方向
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPunchRecords(page?: number, pageSize?: number, competitorId?: string, courseId?: string, controlId?: string, deviceId?: string, sortBy?: GetPunchRecordsSortByEnum, sortOrder?: GetPunchRecordsSortOrderEnum, options?: RawAxiosRequestConfig) {
        return PunchApiFp(this.configuration).getPunchRecords(page, pageSize, competitorId, courseId, controlId, deviceId, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetPunchRecordsSortByEnum = {
    PunchAt: 'punchAt',
    UploadAt: 'uploadAt',
    CreatedAt: 'createdAt',
    Code: 'code',
    CardNbr: 'cardNbr',
    DeviceId: 'deviceId',
    Batch: 'batch',
    Source: 'source'
} as const;
export type GetPunchRecordsSortByEnum = typeof GetPunchRecordsSortByEnum[keyof typeof GetPunchRecordsSortByEnum];
export const GetPunchRecordsSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetPunchRecordsSortOrderEnum = typeof GetPunchRecordsSortOrderEnum[keyof typeof GetPunchRecordsSortOrderEnum];


/**
 * RegistrationApi - axios parameter creator
 */
export const RegistrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createRegistration
         * @param {CreateRegistrationPayload} createRegistrationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegistration: async (createRegistrationPayload: CreateRegistrationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRegistrationPayload' is not null or undefined
            assertParamExists('createRegistration', 'createRegistrationPayload', createRegistrationPayload)
            const localVarPath = `/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRegistrationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteRegistration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRegistration', 'id', id)
            const localVarPath = `/registration/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCompetitorRegistrationInfo
         * @param {string} competitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorRegistrationInfo: async (competitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'competitorId' is not null or undefined
            assertParamExists('getCompetitorRegistrationInfo', 'competitorId', competitorId)
            const localVarPath = `/registration/competitor/{competitorId}`
                .replace(`{${"competitorId"}}`, encodeURIComponent(String(competitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCompetitorsByClassId
         * @param {string} classId 
         * @param {string} registered 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorsByClassId: async (classId: string, registered: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('getCompetitorsByClassId', 'classId', classId)
            // verify required parameter 'registered' is not null or undefined
            assertParamExists('getCompetitorsByClassId', 'registered', registered)
            const localVarPath = `/registration/class/{classId}/competitors`
                .replace(`{${"classId"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (registered !== undefined) {
                localVarQueryParameter['registered'] = registered;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRegistrationById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRegistrationById', 'id', id)
            const localVarPath = `/registration/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRegistrationsByEventId
         * @param {string} event 
         * @param {string} competitor 
         * @param {string} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationsByEventId: async (event: string, competitor: string, _class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getRegistrationsByEventId', 'event', event)
            // verify required parameter 'competitor' is not null or undefined
            assertParamExists('getRegistrationsByEventId', 'competitor', competitor)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getRegistrationsByEventId', '_class', _class)
            const localVarPath = `/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (competitor !== undefined) {
                localVarQueryParameter['competitor'] = competitor;
            }

            if (_class !== undefined) {
                localVarQueryParameter['class'] = _class;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateRegistration
         * @param {string} id 
         * @param {UpdateRegistrationPayload} updateRegistrationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegistration: async (id: string, updateRegistrationPayload: UpdateRegistrationPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRegistration', 'id', id)
            // verify required parameter 'updateRegistrationPayload' is not null or undefined
            assertParamExists('updateRegistration', 'updateRegistrationPayload', updateRegistrationPayload)
            const localVarPath = `/registration/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRegistrationPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationApi - functional programming interface
 */
export const RegistrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createRegistration
         * @param {CreateRegistrationPayload} createRegistrationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRegistration(createRegistrationPayload: CreateRegistrationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRegistrationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRegistration(createRegistrationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistrationApi.createRegistration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteRegistration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRegistration(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRegistration(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistrationApi.deleteRegistration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCompetitorRegistrationInfo
         * @param {string} competitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompetitorRegistrationInfo(competitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorBriefWithClassEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompetitorRegistrationInfo(competitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistrationApi.getCompetitorRegistrationInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCompetitorsByClassId
         * @param {string} classId 
         * @param {string} registered 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompetitorsByClassId(classId: string, registered: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorBriefWithClassEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompetitorsByClassId(classId, registered, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistrationApi.getCompetitorsByClassId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getRegistrationById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRegistrationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegistrationById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistrationApi.getRegistrationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getRegistrationsByEventId
         * @param {string} event 
         * @param {string} competitor 
         * @param {string} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationsByEventId(event: string, competitor: string, _class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRegistrationEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegistrationsByEventId(event, competitor, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistrationApi.getRegistrationsByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateRegistration
         * @param {string} id 
         * @param {UpdateRegistrationPayload} updateRegistrationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRegistration(id: string, updateRegistrationPayload: UpdateRegistrationPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRegistrationEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRegistration(id, updateRegistrationPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistrationApi.updateRegistration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegistrationApi - factory interface
 */
export const RegistrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistrationApiFp(configuration)
    return {
        /**
         * 
         * @summary createRegistration
         * @param {CreateRegistrationPayload} createRegistrationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRegistration(createRegistrationPayload: CreateRegistrationPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRegistrationEntity> {
            return localVarFp.createRegistration(createRegistrationPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteRegistration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegistration(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteRegistration(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCompetitorRegistrationInfo
         * @param {string} competitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorRegistrationInfo(competitorId: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorBriefWithClassEntity> {
            return localVarFp.getCompetitorRegistrationInfo(competitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCompetitorsByClassId
         * @param {string} classId 
         * @param {string} registered 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorsByClassId(classId: string, registered: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorBriefWithClassEntityArray> {
            return localVarFp.getCompetitorsByClassId(classId, registered, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRegistrationById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRegistrationEntity> {
            return localVarFp.getRegistrationById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRegistrationsByEventId
         * @param {string} event 
         * @param {string} competitor 
         * @param {string} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationsByEventId(event: string, competitor: string, _class: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRegistrationEntityArray> {
            return localVarFp.getRegistrationsByEventId(event, competitor, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateRegistration
         * @param {string} id 
         * @param {UpdateRegistrationPayload} updateRegistrationPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegistration(id: string, updateRegistrationPayload: UpdateRegistrationPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRegistrationEntity> {
            return localVarFp.updateRegistration(id, updateRegistrationPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistrationApi - object-oriented interface
 */
export class RegistrationApi extends BaseAPI {
    /**
     * 
     * @summary createRegistration
     * @param {CreateRegistrationPayload} createRegistrationPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRegistration(createRegistrationPayload: CreateRegistrationPayload, options?: RawAxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).createRegistration(createRegistrationPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteRegistration
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRegistration(id: string, options?: RawAxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).deleteRegistration(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCompetitorRegistrationInfo
     * @param {string} competitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCompetitorRegistrationInfo(competitorId: string, options?: RawAxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).getCompetitorRegistrationInfo(competitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCompetitorsByClassId
     * @param {string} classId 
     * @param {string} registered 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCompetitorsByClassId(classId: string, registered: string, options?: RawAxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).getCompetitorsByClassId(classId, registered, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRegistrationById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRegistrationById(id: string, options?: RawAxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).getRegistrationById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRegistrationsByEventId
     * @param {string} event 
     * @param {string} competitor 
     * @param {string} _class 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRegistrationsByEventId(event: string, competitor: string, _class: string, options?: RawAxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).getRegistrationsByEventId(event, competitor, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateRegistration
     * @param {string} id 
     * @param {UpdateRegistrationPayload} updateRegistrationPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRegistration(id: string, updateRegistrationPayload: UpdateRegistrationPayload, options?: RawAxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).updateRegistration(id, updateRegistrationPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResultsApi - axios parameter creator
 */
export const ResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary evaluateResults
         * @param {EvaluateResultsDto} evaluateResultsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateResults: async (evaluateResultsDto: EvaluateResultsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluateResultsDto' is not null or undefined
            assertParamExists('evaluateResults', 'evaluateResultsDto', evaluateResultsDto)
            const localVarPath = `/results/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluateResultsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getResults
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [courseId] 
         * @param {string} [competitorId] 
         * @param {GetResultsStatusEnum} [status] 结果状态过滤: ok(仅返回状态为OK的结果), other(返回状态非OK的结果)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResults: async (page?: number, pageSize?: number, courseId?: string, competitorId?: string, status?: GetResultsStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }

            if (competitorId !== undefined) {
                localVarQueryParameter['competitorId'] = competitorId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResultsApi - functional programming interface
 */
export const ResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary evaluateResults
         * @param {EvaluateResultsDto} evaluateResultsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateResults(evaluateResultsDto: EvaluateResultsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateResults(evaluateResultsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.evaluateResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getResults
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [courseId] 
         * @param {string} [competitorId] 
         * @param {GetResultsStatusEnum} [status] 结果状态过滤: ok(仅返回状态为OK的结果), other(返回状态非OK的结果)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResults(page?: number, pageSize?: number, courseId?: string, competitorId?: string, status?: GetResultsStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCourseResultEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResults(page, pageSize, courseId, competitorId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResultsApi.getResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResultsApi - factory interface
 */
export const ResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResultsApiFp(configuration)
    return {
        /**
         * 
         * @summary evaluateResults
         * @param {EvaluateResultsDto} evaluateResultsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateResults(evaluateResultsDto: EvaluateResultsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.evaluateResults(evaluateResultsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getResults
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [courseId] 
         * @param {string} [competitorId] 
         * @param {GetResultsStatusEnum} [status] 结果状态过滤: ok(仅返回状态为OK的结果), other(返回状态非OK的结果)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResults(page?: number, pageSize?: number, courseId?: string, competitorId?: string, status?: GetResultsStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCourseResultEntityArray> {
            return localVarFp.getResults(page, pageSize, courseId, competitorId, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResultsApi - object-oriented interface
 */
export class ResultsApi extends BaseAPI {
    /**
     * 
     * @summary evaluateResults
     * @param {EvaluateResultsDto} evaluateResultsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public evaluateResults(evaluateResultsDto: EvaluateResultsDto, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).evaluateResults(evaluateResultsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getResults
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [courseId] 
     * @param {string} [competitorId] 
     * @param {GetResultsStatusEnum} [status] 结果状态过滤: ok(仅返回状态为OK的结果), other(返回状态非OK的结果)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getResults(page?: number, pageSize?: number, courseId?: string, competitorId?: string, status?: GetResultsStatusEnum, options?: RawAxiosRequestConfig) {
        return ResultsApiFp(this.configuration).getResults(page, pageSize, courseId, competitorId, status, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetResultsStatusEnum = {
    Ok: 'ok',
    Notok: 'notok'
} as const;
export type GetResultsStatusEnum = typeof GetResultsStatusEnum[keyof typeof GetResultsStatusEnum];


/**
 * RouteApi - axios parameter creator
 */
export const RouteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createRoute
         * @param {CreateRoutePayload} createRoutePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoute: async (createRoutePayload: CreateRoutePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoutePayload' is not null or undefined
            assertParamExists('createRoute', 'createRoutePayload', createRoutePayload)
            const localVarPath = `/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoutePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteControlPoints
         * @param {string} id 
         * @param {DeleteRouteControlPointsPayload} deleteRouteControlPointsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteControlPoints: async (id: string, deleteRouteControlPointsPayload: DeleteRouteControlPointsPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteControlPoints', 'id', id)
            // verify required parameter 'deleteRouteControlPointsPayload' is not null or undefined
            assertParamExists('deleteControlPoints', 'deleteRouteControlPointsPayload', deleteRouteControlPointsPayload)
            const localVarPath = `/route/{id}/controlpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRouteControlPointsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteRoute
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoute: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoute', 'id', id)
            const localVarPath = `/route/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getControlPoints
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlPoints: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getControlPoints', 'id', id)
            const localVarPath = `/route/{id}/controlpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRouteById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteById', 'id', id)
            const localVarPath = `/route/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRoutesByTerrainId
         * @param {string} terrain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesByTerrainId: async (terrain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terrain' is not null or undefined
            assertParamExists('getRoutesByTerrainId', 'terrain', terrain)
            const localVarPath = `/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (terrain !== undefined) {
                localVarQueryParameter['terrain'] = terrain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary insertControlPoints
         * @param {string} id 
         * @param {InsertRouteControlPointsPayload} insertRouteControlPointsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertControlPoints: async (id: string, insertRouteControlPointsPayload: InsertRouteControlPointsPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('insertControlPoints', 'id', id)
            // verify required parameter 'insertRouteControlPointsPayload' is not null or undefined
            assertParamExists('insertControlPoints', 'insertRouteControlPointsPayload', insertRouteControlPointsPayload)
            const localVarPath = `/route/{id}/controlpoints`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insertRouteControlPointsPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary moveControlPoint
         * @param {string} id 
         * @param {MoveRouteControlPointPayload} moveRouteControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveControlPoint: async (id: string, moveRouteControlPointPayload: MoveRouteControlPointPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveControlPoint', 'id', id)
            // verify required parameter 'moveRouteControlPointPayload' is not null or undefined
            assertParamExists('moveControlPoint', 'moveRouteControlPointPayload', moveRouteControlPointPayload)
            const localVarPath = `/route/{id}/controlpoint/move`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveRouteControlPointPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateRoute
         * @param {string} id 
         * @param {UpdateRoutePayload} updateRoutePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoute: async (id: string, updateRoutePayload: UpdateRoutePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRoute', 'id', id)
            // verify required parameter 'updateRoutePayload' is not null or undefined
            assertParamExists('updateRoute', 'updateRoutePayload', updateRoutePayload)
            const localVarPath = `/route/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoutePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RouteApi - functional programming interface
 */
export const RouteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RouteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createRoute
         * @param {CreateRoutePayload} createRoutePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoute(createRoutePayload: CreateRoutePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRouteEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoute(createRoutePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.createRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteControlPoints
         * @param {string} id 
         * @param {DeleteRouteControlPointsPayload} deleteRouteControlPointsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteControlPoints(id: string, deleteRouteControlPointsPayload: DeleteRouteControlPointsPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteControlPoints(id, deleteRouteControlPointsPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.deleteControlPoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteRoute
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoute(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoute(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.deleteRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getControlPoints
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlPoints(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRouteControlPointEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlPoints(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.getControlPoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getRouteById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRouteEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.getRouteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getRoutesByTerrainId
         * @param {string} terrain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutesByTerrainId(terrain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRouteEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutesByTerrainId(terrain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.getRoutesByTerrainId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary insertControlPoints
         * @param {string} id 
         * @param {InsertRouteControlPointsPayload} insertRouteControlPointsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertControlPoints(id: string, insertRouteControlPointsPayload: InsertRouteControlPointsPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRouteControlPointEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertControlPoints(id, insertRouteControlPointsPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.insertControlPoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary moveControlPoint
         * @param {string} id 
         * @param {MoveRouteControlPointPayload} moveRouteControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveControlPoint(id: string, moveRouteControlPointPayload: MoveRouteControlPointPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRouteControlPointEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveControlPoint(id, moveRouteControlPointPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.moveControlPoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateRoute
         * @param {string} id 
         * @param {UpdateRoutePayload} updateRoutePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoute(id: string, updateRoutePayload: UpdateRoutePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfRouteEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoute(id, updateRoutePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RouteApi.updateRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RouteApi - factory interface
 */
export const RouteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RouteApiFp(configuration)
    return {
        /**
         * 
         * @summary createRoute
         * @param {CreateRoutePayload} createRoutePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoute(createRoutePayload: CreateRoutePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRouteEntity> {
            return localVarFp.createRoute(createRoutePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteControlPoints
         * @param {string} id 
         * @param {DeleteRouteControlPointsPayload} deleteRouteControlPointsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteControlPoints(id: string, deleteRouteControlPointsPayload: DeleteRouteControlPointsPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteControlPoints(id, deleteRouteControlPointsPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteRoute
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoute(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteRoute(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getControlPoints
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlPoints(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRouteControlPointEntityArray> {
            return localVarFp.getControlPoints(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRouteById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRouteEntity> {
            return localVarFp.getRouteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRoutesByTerrainId
         * @param {string} terrain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesByTerrainId(terrain: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRouteEntityArray> {
            return localVarFp.getRoutesByTerrainId(terrain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary insertControlPoints
         * @param {string} id 
         * @param {InsertRouteControlPointsPayload} insertRouteControlPointsPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertControlPoints(id: string, insertRouteControlPointsPayload: InsertRouteControlPointsPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRouteControlPointEntityArray> {
            return localVarFp.insertControlPoints(id, insertRouteControlPointsPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary moveControlPoint
         * @param {string} id 
         * @param {MoveRouteControlPointPayload} moveRouteControlPointPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveControlPoint(id: string, moveRouteControlPointPayload: MoveRouteControlPointPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRouteControlPointEntityArray> {
            return localVarFp.moveControlPoint(id, moveRouteControlPointPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateRoute
         * @param {string} id 
         * @param {UpdateRoutePayload} updateRoutePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoute(id: string, updateRoutePayload: UpdateRoutePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfRouteEntity> {
            return localVarFp.updateRoute(id, updateRoutePayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RouteApi - object-oriented interface
 */
export class RouteApi extends BaseAPI {
    /**
     * 
     * @summary createRoute
     * @param {CreateRoutePayload} createRoutePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRoute(createRoutePayload: CreateRoutePayload, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).createRoute(createRoutePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteControlPoints
     * @param {string} id 
     * @param {DeleteRouteControlPointsPayload} deleteRouteControlPointsPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteControlPoints(id: string, deleteRouteControlPointsPayload: DeleteRouteControlPointsPayload, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).deleteControlPoints(id, deleteRouteControlPointsPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteRoute
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRoute(id: string, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).deleteRoute(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getControlPoints
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getControlPoints(id: string, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).getControlPoints(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRouteById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRouteById(id: string, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).getRouteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRoutesByTerrainId
     * @param {string} terrain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRoutesByTerrainId(terrain: string, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).getRoutesByTerrainId(terrain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary insertControlPoints
     * @param {string} id 
     * @param {InsertRouteControlPointsPayload} insertRouteControlPointsPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public insertControlPoints(id: string, insertRouteControlPointsPayload: InsertRouteControlPointsPayload, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).insertControlPoints(id, insertRouteControlPointsPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary moveControlPoint
     * @param {string} id 
     * @param {MoveRouteControlPointPayload} moveRouteControlPointPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public moveControlPoint(id: string, moveRouteControlPointPayload: MoveRouteControlPointPayload, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).moveControlPoint(id, moveRouteControlPointPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateRoute
     * @param {string} id 
     * @param {UpdateRoutePayload} updateRoutePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRoute(id: string, updateRoutePayload: UpdateRoutePayload, options?: RawAxiosRequestConfig) {
        return RouteApiFp(this.configuration).updateRoute(id, updateRoutePayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StageApi - axios parameter creator
 */
export const StageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createStage
         * @param {CreateStagePayload} createStagePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStage: async (createStagePayload: CreateStagePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStagePayload' is not null or undefined
            assertParamExists('createStage', 'createStagePayload', createStagePayload)
            const localVarPath = `/stage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStagePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteStage
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStage', 'id', id)
            const localVarPath = `/stage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getStageById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStageById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStageById', 'id', id)
            const localVarPath = `/stage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getStagesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagesByEventId: async (event: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getStagesByEventId', 'event', event)
            const localVarPath = `/stage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateStage
         * @param {string} id 
         * @param {UpdateStagePayload} updateStagePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStage: async (id: string, updateStagePayload: UpdateStagePayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStage', 'id', id)
            // verify required parameter 'updateStagePayload' is not null or undefined
            assertParamExists('updateStage', 'updateStagePayload', updateStagePayload)
            const localVarPath = `/stage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStagePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StageApi - functional programming interface
 */
export const StageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createStage
         * @param {CreateStagePayload} createStagePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStage(createStagePayload: CreateStagePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfStageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStage(createStagePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StageApi.createStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteStage
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StageApi.deleteStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getStageById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStageById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfStageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStageById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StageApi.getStageById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getStagesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStagesByEventId(event: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfStageEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStagesByEventId(event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StageApi.getStagesByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateStage
         * @param {string} id 
         * @param {UpdateStagePayload} updateStagePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStage(id: string, updateStagePayload: UpdateStagePayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfStageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStage(id, updateStagePayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StageApi.updateStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StageApi - factory interface
 */
export const StageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StageApiFp(configuration)
    return {
        /**
         * 
         * @summary createStage
         * @param {CreateStagePayload} createStagePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStage(createStagePayload: CreateStagePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfStageEntity> {
            return localVarFp.createStage(createStagePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteStage
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStage(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteStage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getStageById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStageById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfStageEntity> {
            return localVarFp.getStageById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getStagesByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagesByEventId(event: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfStageEntityArray> {
            return localVarFp.getStagesByEventId(event, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateStage
         * @param {string} id 
         * @param {UpdateStagePayload} updateStagePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStage(id: string, updateStagePayload: UpdateStagePayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfStageEntity> {
            return localVarFp.updateStage(id, updateStagePayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StageApi - object-oriented interface
 */
export class StageApi extends BaseAPI {
    /**
     * 
     * @summary createStage
     * @param {CreateStagePayload} createStagePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createStage(createStagePayload: CreateStagePayload, options?: RawAxiosRequestConfig) {
        return StageApiFp(this.configuration).createStage(createStagePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteStage
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteStage(id: string, options?: RawAxiosRequestConfig) {
        return StageApiFp(this.configuration).deleteStage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getStageById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStageById(id: string, options?: RawAxiosRequestConfig) {
        return StageApiFp(this.configuration).getStageById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getStagesByEventId
     * @param {string} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStagesByEventId(event: string, options?: RawAxiosRequestConfig) {
        return StageApiFp(this.configuration).getStagesByEventId(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateStage
     * @param {string} id 
     * @param {UpdateStagePayload} updateStagePayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateStage(id: string, updateStagePayload: UpdateStagePayload, options?: RawAxiosRequestConfig) {
        return StageApiFp(this.configuration).updateStage(id, updateStagePayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamApi - axios parameter creator
 */
export const TeamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createTeam
         * @param {CreateTeamPayload} createTeamPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (createTeamPayload: CreateTeamPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamPayload' is not null or undefined
            assertParamExists('createTeam', 'createTeamPayload', createTeamPayload)
            const localVarPath = `/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteTeam
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTeam', 'id', id)
            const localVarPath = `/team/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCompetitorsByTeamId
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorsByTeamId: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCompetitorsByTeamId', 'id', id)
            const localVarPath = `/team/{id}/competitors`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTeamById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeamById', 'id', id)
            const localVarPath = `/team/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTeamsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByEventId: async (event: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getTeamsByEventId', 'event', event)
            const localVarPath = `/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary searchTeams
         * @param {string} eventId 
         * @param {string} name 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeams: async (eventId: string, name: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('searchTeams', 'eventId', eventId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchTeams', 'name', name)
            const localVarPath = `/team/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateTeam
         * @param {string} id 
         * @param {UpdateTeamPayload} updateTeamPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (id: string, updateTeamPayload: UpdateTeamPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeam', 'id', id)
            // verify required parameter 'updateTeamPayload' is not null or undefined
            assertParamExists('updateTeam', 'updateTeamPayload', updateTeamPayload)
            const localVarPath = `/team/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 */
export const TeamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createTeam
         * @param {CreateTeamPayload} createTeamPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(createTeamPayload: CreateTeamPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(createTeamPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.createTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteTeam
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeam(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.deleteTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getCompetitorsByTeamId
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompetitorsByTeamId(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfCompetitorExtEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompetitorsByTeamId(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.getCompetitorsByTeamId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTeamById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.getTeamById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTeamsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamEntityArray1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsByEventId(event, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.getTeamsByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary searchTeams
         * @param {string} eventId 
         * @param {string} name 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTeams(eventId: string, name: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamEntityArray1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTeams(eventId, name, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.searchTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateTeam
         * @param {string} id 
         * @param {UpdateTeamPayload} updateTeamPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(id: string, updateTeamPayload: UpdateTeamPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(id, updateTeamPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.updateTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamApi - factory interface
 */
export const TeamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamApiFp(configuration)
    return {
        /**
         * 
         * @summary createTeam
         * @param {CreateTeamPayload} createTeamPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(createTeamPayload: CreateTeamPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamEntity> {
            return localVarFp.createTeam(createTeamPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteTeam
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteTeam(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCompetitorsByTeamId
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompetitorsByTeamId(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfCompetitorExtEntityArray> {
            return localVarFp.getCompetitorsByTeamId(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTeamById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamEntity> {
            return localVarFp.getTeamById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTeamsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamEntityArray1> {
            return localVarFp.getTeamsByEventId(event, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary searchTeams
         * @param {string} eventId 
         * @param {string} name 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeams(eventId: string, name: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamEntityArray1> {
            return localVarFp.searchTeams(eventId, name, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateTeam
         * @param {string} id 
         * @param {UpdateTeamPayload} updateTeamPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(id: string, updateTeamPayload: UpdateTeamPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamEntity> {
            return localVarFp.updateTeam(id, updateTeamPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamApi - object-oriented interface
 */
export class TeamApi extends BaseAPI {
    /**
     * 
     * @summary createTeam
     * @param {CreateTeamPayload} createTeamPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTeam(createTeamPayload: CreateTeamPayload, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).createTeam(createTeamPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteTeam
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTeam(id: string, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).deleteTeam(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCompetitorsByTeamId
     * @param {string} id 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCompetitorsByTeamId(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).getCompetitorsByTeamId(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTeamById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTeamById(id: string, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).getTeamById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTeamsByEventId
     * @param {string} event 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTeamsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).getTeamsByEventId(event, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary searchTeams
     * @param {string} eventId 
     * @param {string} name 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchTeams(eventId: string, name: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).searchTeams(eventId, name, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateTeam
     * @param {string} id 
     * @param {UpdateTeamPayload} updateTeamPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTeam(id: string, updateTeamPayload: UpdateTeamPayload, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).updateTeam(id, updateTeamPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamResultGroupApi - axios parameter creator
 */
export const TeamResultGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createTeamResultGroup
         * @param {CreateTeamResultGroupPayload} createTeamResultGroupPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createTeamResultGroupPayload: CreateTeamResultGroupPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamResultGroupPayload' is not null or undefined
            assertParamExists('createGroup', 'createTeamResultGroupPayload', createTeamResultGroupPayload)
            const localVarPath = `/team-result-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamResultGroupPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createTeamResultGroupItem
         * @param {string} groupId 
         * @param {CreateTeamResultGroupItemPayload} createTeamResultGroupItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (groupId: string, createTeamResultGroupItemPayload: CreateTeamResultGroupItemPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createItem', 'groupId', groupId)
            // verify required parameter 'createTeamResultGroupItemPayload' is not null or undefined
            assertParamExists('createItem', 'createTeamResultGroupItemPayload', createTeamResultGroupItemPayload)
            const localVarPath = `/team-result-group/{groupId}/items`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamResultGroupItemPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteTeamResultGroup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/team-result-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteTeamResultGroupItem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItem', 'id', id)
            const localVarPath = `/team-result-group/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTeamResultGroupById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupById', 'id', id)
            const localVarPath = `/team-result-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTeamResultGroupsByStageId
         * @param {string} stageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsByStageId: async (stageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stageId' is not null or undefined
            assertParamExists('getGroupsByStageId', 'stageId', stageId)
            const localVarPath = `/team-result-group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stageId !== undefined) {
                localVarQueryParameter['stageId'] = stageId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateTeamResultGroup
         * @param {string} id 
         * @param {UpdateTeamResultGroupPayload} updateTeamResultGroupPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (id: string, updateTeamResultGroupPayload: UpdateTeamResultGroupPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGroup', 'id', id)
            // verify required parameter 'updateTeamResultGroupPayload' is not null or undefined
            assertParamExists('updateGroup', 'updateTeamResultGroupPayload', updateTeamResultGroupPayload)
            const localVarPath = `/team-result-group/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamResultGroupPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamResultGroupApi - functional programming interface
 */
export const TeamResultGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamResultGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createTeamResultGroup
         * @param {CreateTeamResultGroupPayload} createTeamResultGroupPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createTeamResultGroupPayload: CreateTeamResultGroupPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamResultGroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createTeamResultGroupPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamResultGroupApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary createTeamResultGroupItem
         * @param {string} groupId 
         * @param {CreateTeamResultGroupItemPayload} createTeamResultGroupItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(groupId: string, createTeamResultGroupItemPayload: CreateTeamResultGroupItemPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamResultGroupItemEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(groupId, createTeamResultGroupItemPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamResultGroupApi.createItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteTeamResultGroup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamResultGroupApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteTeamResultGroupItem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamResultGroupApi.deleteItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTeamResultGroupById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamResultGroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamResultGroupApi.getGroupById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTeamResultGroupsByStageId
         * @param {string} stageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsByStageId(stageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamResultGroupEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsByStageId(stageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamResultGroupApi.getGroupsByStageId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateTeamResultGroup
         * @param {string} id 
         * @param {UpdateTeamResultGroupPayload} updateTeamResultGroupPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(id: string, updateTeamResultGroupPayload: UpdateTeamResultGroupPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamResultGroupEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(id, updateTeamResultGroupPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamResultGroupApi.updateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamResultGroupApi - factory interface
 */
export const TeamResultGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamResultGroupApiFp(configuration)
    return {
        /**
         * 
         * @summary createTeamResultGroup
         * @param {CreateTeamResultGroupPayload} createTeamResultGroupPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createTeamResultGroupPayload: CreateTeamResultGroupPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamResultGroupEntity> {
            return localVarFp.createGroup(createTeamResultGroupPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createTeamResultGroupItem
         * @param {string} groupId 
         * @param {CreateTeamResultGroupItemPayload} createTeamResultGroupItemPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(groupId: string, createTeamResultGroupItemPayload: CreateTeamResultGroupItemPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamResultGroupItemEntity> {
            return localVarFp.createItem(groupId, createTeamResultGroupItemPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteTeamResultGroup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteTeamResultGroupItem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTeamResultGroupById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamResultGroupEntity> {
            return localVarFp.getGroupById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTeamResultGroupsByStageId
         * @param {string} stageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsByStageId(stageId: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamResultGroupEntityArray> {
            return localVarFp.getGroupsByStageId(stageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateTeamResultGroup
         * @param {string} id 
         * @param {UpdateTeamResultGroupPayload} updateTeamResultGroupPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(id: string, updateTeamResultGroupPayload: UpdateTeamResultGroupPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamResultGroupEntity> {
            return localVarFp.updateGroup(id, updateTeamResultGroupPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamResultGroupApi - object-oriented interface
 */
export class TeamResultGroupApi extends BaseAPI {
    /**
     * 
     * @summary createTeamResultGroup
     * @param {CreateTeamResultGroupPayload} createTeamResultGroupPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGroup(createTeamResultGroupPayload: CreateTeamResultGroupPayload, options?: RawAxiosRequestConfig) {
        return TeamResultGroupApiFp(this.configuration).createGroup(createTeamResultGroupPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createTeamResultGroupItem
     * @param {string} groupId 
     * @param {CreateTeamResultGroupItemPayload} createTeamResultGroupItemPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItem(groupId: string, createTeamResultGroupItemPayload: CreateTeamResultGroupItemPayload, options?: RawAxiosRequestConfig) {
        return TeamResultGroupApiFp(this.configuration).createItem(groupId, createTeamResultGroupItemPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteTeamResultGroup
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGroup(id: string, options?: RawAxiosRequestConfig) {
        return TeamResultGroupApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteTeamResultGroupItem
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItem(id: string, options?: RawAxiosRequestConfig) {
        return TeamResultGroupApiFp(this.configuration).deleteItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTeamResultGroupById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupById(id: string, options?: RawAxiosRequestConfig) {
        return TeamResultGroupApiFp(this.configuration).getGroupById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTeamResultGroupsByStageId
     * @param {string} stageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupsByStageId(stageId: string, options?: RawAxiosRequestConfig) {
        return TeamResultGroupApiFp(this.configuration).getGroupsByStageId(stageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateTeamResultGroup
     * @param {string} id 
     * @param {UpdateTeamResultGroupPayload} updateTeamResultGroupPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateGroup(id: string, updateTeamResultGroupPayload: UpdateTeamResultGroupPayload, options?: RawAxiosRequestConfig) {
        return TeamResultGroupApiFp(this.configuration).updateGroup(id, updateTeamResultGroupPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerrainApi - axios parameter creator
 */
export const TerrainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createTerrain
         * @param {CreateTerrainPayload} createTerrainPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTerrain: async (createTerrainPayload: CreateTerrainPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTerrainPayload' is not null or undefined
            assertParamExists('createTerrain', 'createTerrainPayload', createTerrainPayload)
            const localVarPath = `/terrain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTerrainPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteTerrain
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTerrain: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTerrain', 'id', id)
            const localVarPath = `/terrain/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTerrainById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerrainById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTerrainById', 'id', id)
            const localVarPath = `/terrain/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTerrainsByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerrainsByEventId: async (event: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getTerrainsByEventId', 'event', event)
            const localVarPath = `/terrain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateTerrain
         * @param {string} id 
         * @param {UpdateTerrainPayload} updateTerrainPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTerrain: async (id: string, updateTerrainPayload: UpdateTerrainPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTerrain', 'id', id)
            // verify required parameter 'updateTerrainPayload' is not null or undefined
            assertParamExists('updateTerrain', 'updateTerrainPayload', updateTerrainPayload)
            const localVarPath = `/terrain/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTerrainPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerrainApi - functional programming interface
 */
export const TerrainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerrainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createTerrain
         * @param {CreateTerrainPayload} createTerrainPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTerrain(createTerrainPayload: CreateTerrainPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTerrainEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTerrain(createTerrainPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerrainApi.createTerrain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteTerrain
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTerrain(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTerrain(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerrainApi.deleteTerrain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTerrainById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerrainById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTerrainEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerrainById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerrainApi.getTerrainById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTerrainsByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTerrainsByEventId(event: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTerrainEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTerrainsByEventId(event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerrainApi.getTerrainsByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateTerrain
         * @param {string} id 
         * @param {UpdateTerrainPayload} updateTerrainPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTerrain(id: string, updateTerrainPayload: UpdateTerrainPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTerrainEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTerrain(id, updateTerrainPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerrainApi.updateTerrain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerrainApi - factory interface
 */
export const TerrainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerrainApiFp(configuration)
    return {
        /**
         * 
         * @summary createTerrain
         * @param {CreateTerrainPayload} createTerrainPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTerrain(createTerrainPayload: CreateTerrainPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTerrainEntity> {
            return localVarFp.createTerrain(createTerrainPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteTerrain
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTerrain(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteTerrain(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTerrainById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerrainById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTerrainEntity> {
            return localVarFp.getTerrainById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTerrainsByEventId
         * @param {string} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTerrainsByEventId(event: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTerrainEntityArray> {
            return localVarFp.getTerrainsByEventId(event, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateTerrain
         * @param {string} id 
         * @param {UpdateTerrainPayload} updateTerrainPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTerrain(id: string, updateTerrainPayload: UpdateTerrainPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTerrainEntity> {
            return localVarFp.updateTerrain(id, updateTerrainPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerrainApi - object-oriented interface
 */
export class TerrainApi extends BaseAPI {
    /**
     * 
     * @summary createTerrain
     * @param {CreateTerrainPayload} createTerrainPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTerrain(createTerrainPayload: CreateTerrainPayload, options?: RawAxiosRequestConfig) {
        return TerrainApiFp(this.configuration).createTerrain(createTerrainPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteTerrain
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTerrain(id: string, options?: RawAxiosRequestConfig) {
        return TerrainApiFp(this.configuration).deleteTerrain(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTerrainById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTerrainById(id: string, options?: RawAxiosRequestConfig) {
        return TerrainApiFp(this.configuration).getTerrainById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTerrainsByEventId
     * @param {string} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTerrainsByEventId(event: string, options?: RawAxiosRequestConfig) {
        return TerrainApiFp(this.configuration).getTerrainsByEventId(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateTerrain
     * @param {string} id 
     * @param {UpdateTerrainPayload} updateTerrainPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTerrain(id: string, updateTerrainPayload: UpdateTerrainPayload, options?: RawAxiosRequestConfig) {
        return TerrainApiFp(this.configuration).updateTerrain(id, updateTerrainPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UnitApi - axios parameter creator
 */
export const UnitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createUnit
         * @param {CreateUnitPayload} createUnitPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit: async (createUnitPayload: CreateUnitPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUnitPayload' is not null or undefined
            assertParamExists('createUnit', 'createUnitPayload', createUnitPayload)
            const localVarPath = `/unit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUnitPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteUnit
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnit: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUnit', 'id', id)
            const localVarPath = `/unit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTeamsByUnitId
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByUnitId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTeamsByUnitId', 'id', id)
            const localVarPath = `/unit/{id}/teams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUnitById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUnitById', 'id', id)
            const localVarPath = `/unit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUnitsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitsByEventId: async (event: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('getUnitsByEventId', 'event', event)
            const localVarPath = `/unit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary searchUnits
         * @param {string} eventId 
         * @param {string} name 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnits: async (eventId: string, name: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('searchUnits', 'eventId', eventId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('searchUnits', 'name', name)
            const localVarPath = `/unit/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateUnit
         * @param {string} id 
         * @param {UpdateUnitPayload} updateUnitPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit: async (id: string, updateUnitPayload: UpdateUnitPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUnit', 'id', id)
            // verify required parameter 'updateUnitPayload' is not null or undefined
            assertParamExists('updateUnit', 'updateUnitPayload', updateUnitPayload)
            const localVarPath = `/unit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUnitPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnitApi - functional programming interface
 */
export const UnitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnitApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary createUnit
         * @param {CreateUnitPayload} createUnitPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUnit(createUnitPayload: CreateUnitPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfUnitEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUnit(createUnitPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.createUnit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary deleteUnit
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUnit(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUnit(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.deleteUnit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getTeamsByUnitId
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamsByUnitId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfTeamEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsByUnitId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getTeamsByUnitId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getUnitById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfUnitEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getUnitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getUnitsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnitsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfUnitEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnitsByEventId(event, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.getUnitsByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary searchUnits
         * @param {string} eventId 
         * @param {string} name 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUnits(eventId: string, name: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfUnitEntityArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUnits(eventId, name, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.searchUnits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateUnit
         * @param {string} id 
         * @param {UpdateUnitPayload} updateUnitPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUnit(id: string, updateUnitPayload: UpdateUnitPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestDataResponseOfUnitEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUnit(id, updateUnitPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitApi.updateUnit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UnitApi - factory interface
 */
export const UnitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnitApiFp(configuration)
    return {
        /**
         * 
         * @summary createUnit
         * @param {CreateUnitPayload} createUnitPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit(createUnitPayload: CreateUnitPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfUnitEntity> {
            return localVarFp.createUnit(createUnitPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteUnit
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnit(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestResponse> {
            return localVarFp.deleteUnit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTeamsByUnitId
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamsByUnitId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfTeamEntityArray> {
            return localVarFp.getTeamsByUnitId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUnitById
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfUnitEntity> {
            return localVarFp.getUnitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUnitsByEventId
         * @param {string} event 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfUnitEntityArray> {
            return localVarFp.getUnitsByEventId(event, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary searchUnits
         * @param {string} eventId 
         * @param {string} name 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnits(eventId: string, name: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfUnitEntityArray> {
            return localVarFp.searchUnits(eventId, name, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateUnit
         * @param {string} id 
         * @param {UpdateUnitPayload} updateUnitPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit(id: string, updateUnitPayload: UpdateUnitPayload, options?: RawAxiosRequestConfig): AxiosPromise<RestDataResponseOfUnitEntity> {
            return localVarFp.updateUnit(id, updateUnitPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnitApi - object-oriented interface
 */
export class UnitApi extends BaseAPI {
    /**
     * 
     * @summary createUnit
     * @param {CreateUnitPayload} createUnitPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUnit(createUnitPayload: CreateUnitPayload, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).createUnit(createUnitPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteUnit
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUnit(id: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).deleteUnit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTeamsByUnitId
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTeamsByUnitId(id: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getTeamsByUnitId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUnitById
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUnitById(id: string, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getUnitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUnitsByEventId
     * @param {string} event 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUnitsByEventId(event: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).getUnitsByEventId(event, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary searchUnits
     * @param {string} eventId 
     * @param {string} name 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchUnits(eventId: string, name: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).searchUnits(eventId, name, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateUnit
     * @param {string} id 
     * @param {UpdateUnitPayload} updateUnitPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUnit(id: string, updateUnitPayload: UpdateUnitPayload, options?: RawAxiosRequestConfig) {
        return UnitApiFp(this.configuration).updateUnit(id, updateUnitPayload, options).then((request) => request(this.axios, this.basePath));
    }
}



